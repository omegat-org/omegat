import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens

plugins {
    id 'application'
    id 'java-library'
    id 'java-test-fixtures'
    id 'maven-publish'
    id 'signing'
    id 'eclipse'
    id 'checkstyle'
    id 'jacoco'
    id 'com.github.spotbugs' version '4.7.10'
    id 'org.hidetake.ssh' version '2.10.1'
    id 'com.diffplug.spotless' version '6.0.0'
    id 'com.github.ben-manes.versions' version '0.39.0'
    id 'edu.sc.seis.launch4j' version '3.0.3'
}

apply from: 'gradle/utils.gradle'

applicationName = 'OmegaT'
mainClassName = 'org.omegat.Main'

ext {
    omtVersion = loadProperties(file('src/org/omegat/Version.properties'))
    omtFlavor = omtVersion.beta.empty ? 'standard' : 'latest'
    omtWebsite = 'https://omegat.org'
    localPropsFile = file('local.properties')
    if (localPropsFile.file) {
        loadProperties(localPropsFile).each { k, v ->
            if (!findProperty(k)) {
                set(k, v)
            }
        }
    }
}

version = omtVersion.version + getUpdateSuffix(omtVersion.update)

java {
    withSourcesJar()
    withJavadocJar()
}

allprojects {
    def javaVersion = 11;
    def envIsCi = project.hasProperty('envIsCi') as Boolean

    apply plugin: 'checkstyle'
    apply plugin: 'java-library'
    apply plugin: 'eclipse'
    apply plugin: 'com.github.spotbugs'
    apply plugin: 'com.diffplug.spotless'

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(javaVersion)
            vendor = JvmVendorSpec.ADOPTIUM
        }
    }

    javadoc {
        failOnError = false
        options {
            jFlags('-Duser.language=en')
            addStringOption('locale', 'en_US')
            addStringOption('bottom', '<span>Copyright 2000-2023, OmegaT project and contributors</span>')
            addStringOption('encoding', 'UTF-8')
            addBooleanOption("Xdoclint:none", true)
            addBooleanOption('html5', true)
            addBooleanOption('frames', false)
            addBooleanOption('public', true)
        }
    }
    tasks.withType(JavaCompile) {
       options.encoding = "UTF-8"
       options.compilerArgs.addAll '-Xlint', '-Werror'
    }

    sourcesJar {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    spotbugs {
        reportLevel = 'high'
    }

    tasks.findAll { it.name =~ /^spotbugs.*/ }.each {
        it.reports {
            xml.required = envIsCi
            html.required = !envIsCi
        }
    }

    checkstyle {
        toolVersion = '8.45.1'
    }
    checkstyleMain.exclude '**/gen/**'

    spotless {
        enforceCheck false
        java {
            targetExclude 'src/gen/**'
            eclipse().configFile 'docs_devel/docs/assets/eclipse-formatting.xml'
            removeUnusedImports()
        }
    }

    repositories {
        mavenCentral()
        mavenLocal()
        // Sonatype OSSRH snapshots
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots" }
    }
}

subprojects {
    // All subproject dpenends on main project.
    dependencies {
        compileOnly(project.rootProject)
        testImplementation(testFixtures(project.rootProject))
    }
}

sourceSets {
    main {
        java {
            srcDir 'src'
        }
        resources {
            srcDir 'src'
        }
    }
    test {
        java {
            srcDir 'test/src'
        }
        resources {
            srcDir 'test/src'
            srcDir 'test/data'
        }
    }
    testFixtures {
        java {
            srcDir 'test/fixtures'
        }
    }
    testIntegration {
        java {
            srcDir 'test-integration/src'
        }
    }
}

configurations {
    all
    [testRuntime, testCompile]*.exclude group: 'org.languagetool', module: 'language-all'
    testIntegrationImplementation.extendsFrom implementation
    jaxb
}

ext {
    providedLibsDir = file('lib/provided')
    languageToolVersion = '6.1'
    luceneVersion = '5.5.5'
    luceneGosenVersion = '5.5.1'
    jgitVersion = '6.6.0.202305301015-r'
    slf4jVersion = '2.0.7'
}

dependencies {
    // Libs are provided in the "source" distribution only
    if (providedLibsDir.directory) {
        implementation fileTree(dir: providedLibsDir, include: '**/*.jar')
    } else {
        implementation 'commons-io:commons-io:2.11.0'
        implementation 'org.apache.commons:commons-lang3:3.11'
        runtimeOnly "org.slf4j:slf4j-jdk14:${slf4jVersion}"

        // macOS integration
        implementation 'org.madlonkay:desktopsupport:0.6.0'

        // stax
        implementation 'org.codehaus.woodstox:stax2-api:4.2.1'
        runtimeOnly 'com.fasterxml.woodstox:woodstox-core:6.5.0'

        // Data: inline data URL handler
        implementation 'tokyo.northside:url-protocol-handler:0.1.4'

        // PDF Filter
        implementation 'org.apache.pdfbox:pdfbox:2.0.27'

        // Aligner
        implementation 'net.loomchild:maligna:3.0.1'

        // Dictionary
        implementation 'com.github.takawitter:trie4j:0.9.8'
        implementation('io.github.eb4j:dsl4j:0.5.3') {
            exclude module: 'annotations'
        }
        // Explicit specification of annotations version
        implementation 'org.jetbrains:annotations:23.0.0'
        implementation 'tokyo.northside:stardict4j:0.5.0'
        implementation 'org.jsoup:jsoup:1.15.3'

        // Encoding detections
        implementation 'com.github.albfernandez:juniversalchardet:2.4.0'

        // Legacy projects re-hosted on Maven Central
        api 'org.omegat:vldocking:3.0.5'
        implementation 'org.omegat:htmlparser:1.6-20230203'
        implementation 'org.omegat:gnudiff4j:1.15'
        implementation 'org.omegat:lib-mnemonics:1.1'
        implementation 'org.omegat:jmyspell-core:1.0.0-beta-2'

        // LanguageTool
        implementation("org.languagetool:languagetool-core:${languageToolVersion}") {
            exclude module: 'guava'
            exclude module: 'jackson-databind'
            exclude group: 'org.jetbrains'
        }
        // Explicitly specify guava dependency for `jre` version rather than `-android`
        implementation 'com.google.guava:guava:31.0.1-jre'
        runtimeOnly("org.languagetool:language-all:${languageToolVersion}") {
            // Temporary exclusion; see https://sourceforge.net/p/omegat/bugs/814/
            exclude module: 'lucene-gosen'
        }
        runtimeOnly 'org.omegat.lucene:lucene-gosen:5.5.1:ipadic'

        // Lucene for tokenizers
        implementation "org.apache.lucene:lucene-core:${luceneVersion}"
        implementation "org.apache.lucene:lucene-analyzers-common:${luceneVersion}"
        implementation "org.apache.lucene:lucene-analyzers-kuromoji:${luceneVersion}"
        implementation "org.apache.lucene:lucene-analyzers-smartcn:${luceneVersion}"
        implementation "org.apache.lucene:lucene-analyzers-stempel:${luceneVersion}"

        // Team project server support
        implementation "org.eclipse.jgit:org.eclipse.jgit:${jgitVersion}"
        implementation "org.eclipse.jgit:org.eclipse.jgit.ssh.apache:${jgitVersion}"
        implementation "org.eclipse.jgit:org.eclipse.jgit.ssh.apache.agent:${jgitVersion}"
        implementation "org.eclipse.jgit:org.eclipse.jgit.http.apache:${jgitVersion}"
        // For ed25519 and ecdsa support of ssh, java16+ or BC
        implementation 'org.bouncycastle:bcprov-jdk18on:1.72'
        implementation 'org.bouncycastle:bcpg-jdk18on:1.72'
        implementation 'org.bouncycastle:bcpkix-jdk18on:1.72'
        implementation 'net.i2p.crypto:eddsa:0.3.0'
        // For gpg signing
        implementation "org.eclipse.jgit:org.eclipse.jgit.gpg.bc:${jgitVersion}"

        // For subversion
        implementation 'org.tmatesoft.svnkit:svnkit:1.10.11'

        // Team project conflict resolution
        implementation 'org.madlonkay:supertmxmerge:2.0.3'

        // Credentials encryption
        implementation 'org.jasypt:jasypt:1.9.3'

        // Groovy used for scripts - needed at implementation for GroovyClassLoader modifications
        // Ivy is needed to handle Grape/@Grab dependencies
        runtimeOnly('org.apache.groovy:groovy-all:4.0.11@pom') {
            transitive = true
        }
        runtimeOnly 'org.apache.groovy:groovy-dateutil:4.0.11'
        runtimeOnly 'org.apache.ivy:ivy:2.5.1'

        // Javascript used for scripts
        implementation 'org.openjdk.nashorn:nashorn-core:15.4'

        // Script editor
        implementation 'com.fifesoft:rsyntaxtextarea:3.2.0'
        implementation 'com.fifesoft:rstaui:3.2.0'
        implementation ('com.fifesoft:languagesupport:3.1.4') {
            exclude module: 'rhino'
        }
        implementation 'com.fifesoft:autocomplete:3.2.0'

        // JSON parser
        implementation "com.fasterxml.jackson.core:jackson-core:2.14.2"
        implementation "com.fasterxml.jackson.core:jackson-databind:2.14.2"
        implementation "com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.14.2"
        implementation 'com.fasterxml.jackson.module:jackson-module-jaxb-annotations:2.14.2'

        implementation("com.github.ben-manes.caffeine:caffeine:2.9.3") {
            attributes {
                attribute(Bundling.BUNDLING_ATTRIBUTE, project.objects.named(Bundling.class, Bundling.EXTERNAL))
            }
        }

        implementation("com.github.ben-manes.caffeine:jcache:2.9.3") {
            exclude module: 'caffeine'
            attributes {
                attribute(Bundling.BUNDLING_ATTRIBUTE, project.objects.named(Bundling.class, Bundling.EXTERNAL))
            }
        }

        // dependencies in submodules, you should put it as compileOnly in subprojects
        runtimeOnly "tokyo.northside:tipoftheday:0.4.1"
        runtimeOnly "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.14.2"
    }

    // Test dependencies

    testFixturesApi 'junit:junit:4.13.2'
    // for http connection test
    testFixturesApi 'com.github.tomakehurst:wiremock-jre8:2.35.0'
    testFixturesImplementation 'commons-io:commons-io:2.11.0'

    testImplementation 'org.xmlunit:xmlunit-legacy:2.8.3'
    testImplementation("org.languagetool:languagetool-server:${languageToolVersion}") {
        exclude group: 'org.slf4j'
        exclude group: 'ch.qos.logback'
    }
    // LanguageTool unit tests exercise these languages
    ['be', 'en', 'fr'].each {
        testImplementation "org.languagetool:language-${it}:${languageToolVersion}"
    }
    testImplementation("org.languagetool:language-ja:${languageToolVersion}") {
        // Temporary exclusion; see https://sourceforge.net/p/omegat/bugs/814/
        exclude module: 'lucene-gosen'
    }
    testRuntimeOnly "org.omegat.lucene:lucene-gosen:${luceneGosenVersion}:ipadic"
    testRuntimeOnly "org.languagetool:language-pl:${languageToolVersion}"
    testRuntimeOnly "org.slf4j:slf4j-jdk14:${slf4jVersion}"

    // JAXB codegen only
    jaxb 'com.sun.xml.bind:jaxb-xjc:2.3.4'

    testIntegrationImplementation sourceSets.main.output, sourceSets.test.output
    testIntegrationImplementation(testFixtures(project.rootProject))
    testIntegrationRuntimeOnly "org.slf4j:slf4j-jdk14:${slf4jVersion}"
}

jar {
    def omtPlugins = loadProperties(file('Plugins.properties'))
    manifest {
        attributes('License': 'GNU Public License version 3 or later',
                   'Implementation-Version': project.version,
                   'Permissions': 'all-permissions',
                   'OmegaT-Plugin': 'true',
                   'OmegaT-Plugins': omtPlugins.plugin,
                   'Plugin-Author': 'OmegaT team',
                   'Plugin-Link': 'https://omegat.org',
                   'Plugin-Version': project.version,
                   'Main-Class': mainClassName,
                   'Class-Path': configurations.runtimeClasspath.collect { "lib/${it.name}" }.join(' '))
        ext.pluginAttr = { name, path, category, description ->
            attributes('Plugin-Name': name, 'Plugin-Category': category, 'Plugin-Description': description, path)
        }
        def desc = [:]
        omtPlugins.each { key, val ->
            if (key.startsWith('plugin.desc')) {
                desc[key.split('\\.').last()] = val
            } else if (key != 'plugin') {
                val.tokenize().each { cls ->
                    attributes('OmegaT-Plugin': key, cls)
                }
            }
        }
        pluginAttr('Dictionary driver[bundle]', 'org/omegat/core/dictionaries/', 'dictionary', desc.dictionary)
        pluginAttr('File filters[bundle]', 'org/omegat/filters2/', 'filter', desc.filters2)
        pluginAttr('XML filters[bundle]', 'org/omegat/filters3/', 'filter', desc.filters3)
        pluginAttr('New XML filters[bundle]', 'org/omegat/filters4/', 'filter', desc.filters4)
        pluginAttr('Tokenizers[bundle]', 'org/omegat/tokenizer/', 'tokenizer', desc.tokenizer)
        pluginAttr('Themes [bundle]', 'org/omegat/gui/theme/', 'theme', desc.theme)
        pluginAttr('Scripting engine', 'org/omegat/gui/script/', 'miscellaneous', desc.script)
        pluginAttr('GUI extensions', 'org/omegat/util/gui/', 'miscellaneous', desc.guiutil)
        pluginAttr('Local external search', 'org/omegat/externalfinder/', 'miscellaneous', desc.externalfinder)
    }
    // Don't include extra stuff like version number in JAR name
    archiveFileName.set("${archiveBaseName.get()}.${archiveExtension.get()}")
}

ext {
    distsDir = file("${buildDir}/${distsDirName}")

    assetDir = findProperty('assetDir') ?: '../'

    macJRE = fileTree(dir: assetDir, include: 'OpenJDK11U-jre_x64_mac_*.tar.gz')
    armMacJRE = fileTree(dir: assetDir, include: 'OpenJDK11U-jre_aarch64_mac_*.tar.gz')
    linux64JRE = fileTree(dir: assetDir, include: 'OpenJDK11U-jre_x64_linux_*.tar.gz')
    linuxArm64JRE = fileTree(dir: assetDir, include: 'OpenJDK11U-jre_aarch64_linux_*.tar.gz')
    windowsJRE = fileTree(dir: assetDir, include: 'OpenJDK11U-jre_x64_windows_*.zip')
}

launch4j {
    xmlFileName = "${projectDir}/release/win32-specific/L4j_OMT.xml"
    icon = "${projectDir}/images/OmegaT.ico"
}

task genDocIndex(type: Copy) {
    description = 'Generate the docs index file'
    def docPropsFiles = fileTree(dir: 'docs', include: '*/version*.properties').findAll {
        file("${it.parent}/index.html").file
    }
    def isgFiles = fileTree(dir: 'docs', include: '*/instantStartGuideNoTOC.html').findAll {
        file("${it.parent}/instantStartGuideNoTOC.html").file
    }
    inputs.files docPropsFiles
    from('doc_src') {
        include 'index_template.html'
    }
    into 'docs'
    rename('index_template.html', 'index.html')
    doFirst {
        def langNameExceptions = loadProperties(file('doc_src/lang_exceptions.properties'))
        def isgInfos = isgFiles.collect { isg ->
            def code = isg.parentFile.name
            def locale = Locale.forLanguageTag(code.replace('_', '-'))
            def name = langNameExceptions[code] ?: locale.getDisplayName(locale)
            def docVersion = 0
            def noManual = true
            def status = 'out-of-date'
            ['code': code, 'name': name, 'version': docVersion, 'status': status, 'nomanual': noManual]
        }
        def langInfos = docPropsFiles.collect { props ->
            def code = props.parentFile.name
            def locale = Locale.forLanguageTag(code.replace('_', '-'))
            def name = langNameExceptions[code] ?: locale.getDisplayName(locale)
            def docVersion = loadProperties(props).version
            def noManual = false
            def status = docVersion == omtVersion.version ? 'up-to-date' : 'out-of-date'
            ['code': code, 'name': name, 'version': docVersion, 'status': status, 'nomanual': noManual]
        }
        def filterSet = langInfos.collect {entry -> entry.code}
        def filteredIsgInfos = isgInfos.findAll{entry -> !filterSet.contains(entry.code)}
        langInfos.addAll(filteredIsgInfos)
        langInfos.sort { entry -> entry.code }
        expand('languages': langInfos)
        filteringCharset = 'UTF-8'
    }
}

task webManual(type: Sync) {
    group = 'documentation'
    description = 'Generate the HTML manual'
    dependsOn genDocIndex
    destinationDir = file("${buildDir}/docs/manual")
    from 'docs'
    from('release') {
        include 'doc-license.txt'
    }
}

distributions {
    main {
        contents {
            from('docs') {
                into 'docs'
                exclude 'index.html'
            }
            from(genDocIndex.outputs) {
                into 'docs'
                include 'index.html'
            }
            from('release') {
                into 'docs'
                include 'changes.txt', 'doc-license.txt', 'OmegaT-license.txt', 'contributors.txt', 'libraries.txt'
                filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            }
            from('scripts') {
                into 'scripts'
            }
            from('images') {
                into 'images'
            }
            from('release') {
                exclude 'contributors.txt', 'libraries.txt'
                include '*.txt', '*.html'
                filter(ReplaceTokens, tokens: [
                        TRANSLATION_NOTICE: ''
                ])
                filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            }
            from('release/plugins-specific') {
                into 'plugins'
            }
            from('release/linux-specific') {
                filter ReplaceTokens, tokens: [
                        VERSION_NUMBER_SUBST: project.version,
                        JAR_SUBST           : jar.archiveFileName.get()
                ]
                fileMode 0755
            }
            from('release/win32-specific') {
                include 'OmegaT.bat'
                filter(ReplaceTokens, tokens: [
                        JAR_SUBST           : jar.archiveFileName.get()
                ])
            }
            from('build/launch4j') {
                include '*.exe'
            }
            from('lib/licenses') {
                into 'lib'
            }
            // system core plugins into modules
            from('releases/modules-specific') {
                into 'modules'
            }
            from(subprojects.collect {it.tasks.withType(Jar)}) {
                into 'modules'
            }
            eachFile {
                // Move main JAR up one level from lib.
                def omegatJarFilename = jar.archiveFileName.get()
                if (it.name == omegatJarFilename) {
                    it.relativePath = it.relativePath.parent.parent.append(true, omegatJarFilename)
                }
            }
        }
        distZip.archiveFileName.set("${applicationName}_${version}${omtVersion.beta}_Without_JRE.zip")
    }

    source {
        contents {
            from(rootDir) {
                include 'config/**', 'docs/**', 'images/**', 'lib/**', 'release/**',
                    'src/**', 'test/**', 'doc_src/**', 'docs_devel/**', 'scripts/**',
                    'gradle/**', 'gradlew*', '*.gradle', 'README.md', '*.properties',
                    'tipoftheday/**'
                exclude '**/build/**', 'doc_src/**/pdf/**', 'local.properties'
            }
            into('lib/provided') {
                from configurations.runtimeClasspath
            }
            into('lib/provided') {
                // collect subproject runtime dependencies
                from  {subprojects.findAll { it.getSubprojects().isEmpty()}.
                        collect { it.configurations.runtimeClasspath }
                }
            }
        }
        sourceDistZip.archiveFileName.set("${applicationName}_${version}${omtVersion.beta}_Source.zip")
    }

    mac {
        contents {
            from('release/mac-specific') {
                exclude '**/MacOS/OmegaT', '**/Info.plist', '**/java.entitlements'
            }
            from('release/mac-specific') {
                include '**/MacOS/OmegaT'
                fileMode 0755
            }
            from('release/mac-specific') {
                include '**/Info.plist'
                expand(version: project.version,
                       // $APP_ROOT is expanded at runtime by the launcher binary
                       configfile: '$APP_ROOT/Contents/Resources/Configuration.properties')
            }
            into('OmegaT.app/Contents/Java') {
                with main.contents
                exclude '*.sh', '*.kaptn', 'OmegaT', 'OmegaT.bat', 'omegat.desktop', '*.exe'
            }
            if (!macJRE.empty) {
                from(tarTree(macJRE.singleFile)) {
                    into 'OmegaT.app/Contents/PlugIns'
                    includeEmptyDirs = false
                    eachFile {
                        replaceRelativePathSegment(it, /jdk.*-jre/, 'jre.bundle')
                    }
                }
            }
        }
    }

    linux64 {
        contents {
            with main.contents
            exclude 'OmegaT.bat', '*.exe'
            if (!linux64JRE.empty) {
                from(tarTree(linux64JRE.singleFile)) {
                    includeEmptyDirs = false
                    eachFile {
                        replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                    }
                }
            }
        }
    }

    linuxArm64 {
        contents {
            with main.contents
            exclude 'OmegaT.bat'
            if (!linuxArm64JRE.empty) {
                from(tarTree(linuxArm64JRE.singleFile)) {
                    includeEmptyDirs = false
                    eachFile {
                        replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                    }
                }
            }
        }
    }
}

installMacDist {
    doFirst {
        delete "$destinationDir/OmegaT.app/Contents/PlugIns/jre.bundle"
    }
}

def hunspellJar = configurations.runtimeClasspath.files.find {
    it.name.startsWith('hunspell')
}

task hunspellJarSignedContents(type: Sync) {
    onlyIf {
        // Set this in e.g. local.properties
        condition(project.hasProperty('macCodesignIdentity'), 'Code signing property not set')
    }
    from zipTree(hunspellJar)
    destinationDir = file("$buildDir/hunspell")
    doLast {
        def dylibs = fileTree(dir: destinationDir, include: '**/*.dylib').files
        exec {
            commandLine('codesign', '--deep', '--force',
                        '--sign', project.property('macCodesignIdentity'),
                        '--timestamp',
                        '--options', 'runtime',
                        '--entitlements', file('release/mac-specific/java.entitlements'),
                        *dylibs.toList())
        }
    }
}

task hunspellSignedJar(type: Jar) {
    from hunspellJarSignedContents.outputs
    archiveFileName.set(hunspellJar.name)
}

task installMacSignedDist(type: Sync) {
    description = 'Build the signed Mac distribution. Requires an Apple Developer Account.'
    onlyIf {
        // Set this in e.g. local.properties
        condition(project.hasProperty('macCodesignIdentity'), 'Code signing property not set')
    }
    with distributions.mac.contents
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    from(hunspellSignedJar.outputs) {
        into 'OmegaT.app/Contents/Java/lib'
    }
    destinationDir = file("${buildDir}/install/${applicationName}-macSigned")
    doFirst {
        delete "$destinationDir/OmegaT.app/Contents/PlugIns/jre.bundle"
    }
    doLast {
        exec {
            commandLine 'codesign', '--deep', '--force',
                '--sign', project.property('macCodesignIdentity'),
                '--timestamp',
                '--options', 'runtime',
                '--entitlements', file('release/mac-specific/java.entitlements'),
                file("${destinationDir}/OmegaT.app")
        }
    }
}

macDistZip {
    onlyIf {
        condition(!macJRE.empty, 'JRE not found')
    }
    archiveFileName.set("${applicationName}_${project.version}${omtVersion.beta}_Mac.zip")
    group = 'omegat distribution'
}

task macSignedDistZip(type: Zip) {
    def zipRoot = "${applicationName}_${project.version}${omtVersion.beta}_Mac_Signed"
    from(installMacSignedDist.outputs) {
        into zipRoot
    }
    archiveFileName.set("${zipRoot}.zip")
    group = 'omegat distribution'
}

task macNotarize {
    onlyIf {
        condition(project.hasProperty('macNotarizationUsername'),
                  'Username for notarization not set')
    }
    inputs.files macSignedDistZip.outputs.files
    doLast {
        exec {
            // Assuming setup per instructions at
            // https://developer.apple.com/documentation/security/notarizing_your_app_before_distribution/customizing_the_notarization_workflow#3087734
            commandLine 'xcrun', 'altool', '--notarize-app',
                '--primary-bundle-id', "org.omegat.$version",
                '--username', project.property('macNotarizationUsername'),
                '--password', '@keychain:AC_PASSWORD',
                '--file', inputs.files.singleFile
        }
    }
    group = 'omegat distribution'
}

task macStapledNotarizedDistZip(type: Zip) {
    def zipRoot = "${applicationName}_${project.version}${omtVersion.beta}_Mac_Notarized"
    from(installMacSignedDist.outputs) {
        into zipRoot
    }
    doFirst {
        def app = "${installMacSignedDist.destinationDir}/OmegaT.app"
        exec {
            commandLine 'xcrun', 'stapler', 'staple', app
        }
    }
    archiveFileName.set("${zipRoot}.zip")
    group = 'omegat distribution'
}

task mac(dependsOn: [macDistZip, macNotarize]) {
    description = 'Build the Mac distributions.'
    group = 'omegat distribution'
}

linux64DistTar {
    onlyIf {
        condition(!linux64JRE.empty, 'JRE not found')
    }
    doFirst {
        delete "$destinationDirectory/jre"
    }
    archiveFileName.set("${applicationName}_${project.version}${omtVersion.beta}_Linux_64.tar.bz2")
    compression = Compression.BZIP2
    archiveExtension = 'tar.bz2'
    group = 'omegat distribution'
}

linuxArm64DistTar {
    onlyIf {
        condition(!linuxArm64JRE.empty, 'ARM64 JRE not found')
    }
    doFirst {
        delete "$destinationDirectory/jre"
    }
    archiveFileName.set("${applicationName}_${project.version}${omtVersion.beta}_Linux_ARM64.tar.bz2")
    compression = Compression.BZIP2
    archiveExtension = 'tar.bz2'
    group = 'omegat distribution'
}

task linux(dependsOn: [linux64DistTar, linuxArm64DistTar]) {
    description = 'Build the Linux distributions.'
    group = 'omegat distribution'
}

// We bundle our startup scripts separately, so disable startScripts.
startScripts.enabled = false

// installDist insists on installing a script. Trick it with a dummy script.
installDist.doFirst {
    startScripts.outputDir.mkdirs()
    file("${startScripts.outputDir}/${applicationName}").createNewFile()
    if (destinationDir.directory) {
        // As of Gradle 4.4(?) the application plugin expects `lib` as well
        ['lib', 'bin'].each { file("${destinationDir}/${it}").mkdirs() }
    }
}
// Delete dummy afterwards.
installDist.doLast {
    delete "${destinationDir}/bin"
    delete startScripts.outputDir
}

// Read in all our custom messages and massage them for inclusion in the .iss
ext.getInnoSetupCustomMessages = {
    // Don't include languages that InnoSetup doesn't have strings for
    def blacklist = ['cy', 'ia', 'mfe']
    // Sort files to ensure English comes first, to set fallback
    fileTree(dir: 'release/win32-specific', include: 'CustomMessages*.ini')
        .sort()
        .collect { file ->
            def match = file.name =~ /CustomMessages_?([^\.]*).ini/
            if (match) {
                def capture = match.group(1)
                def lang = capture.empty ? 'en' : capture
                if (!blacklist.contains(lang)) {
                    file.text.replaceAll(/(?m)^([^=]+)/) { "$lang.${it[0]}" }
                }
            }
        }.findAll()
        .join(System.lineSeparator())
}

task win {
    description = 'Build the Windows distributions.'
    group = 'omegat distribution'
}

ext.makeWinTask = { args ->
    def fullVersion = project.version + omtVersion.beta
    def installerBasename = "OmegaT_${fullVersion}_${args.suffix}"
    def installerExe = "${distsDir}/${installerBasename}.exe"
    task(type: Sync, args.name) {
        description = "Create a Windows installer for ${args.name} distro. " +
            'Requires Inno Setup (http://www.jrsoftware.org/isinfo.php).'
        with distributions.main.contents
        dependsOn createAllExecutables
        from ('release/win32-specific') {
            include 'OmegaT.l4J.ini'
        }
        if (args.jrePath && !args.jrePath.empty) {
            from (zipTree(args.jrePath.singleFile)) {
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                }
            }
        }
        destinationDir = file("${buildDir}/innosetup/${args.name}")
        outputs.file installerExe
        onlyIf {
            conditions([!args.jrePath || !args.jrePath.empty, 'JRE not found'],
                       [exePresent('iscc') || exePresent('docker'),
                        'InnoSetup or Docker not installed'])
        }
        doFirst {
            delete "$destinationDir/jre"
            delete installerExe
            project.copy {
                from 'build'
                into 'build'
                include "innosetup/${args.name}/**/*"
                dirMode 0777
                fileMode 0666
            }
        }
        doLast {
            project.copy {
                from('release/win32-specific') {
                    include 'OmegaT.iss'
                }
                into(destinationDir)
                filter(ReplaceTokens, tokens: [
                    VERSION_NUMBER_SUBST: fullVersion,
                    OUTPUT_BASENAME_SUBST: installerBasename.toString(),
                    CUSTOM_MESSAGES_SUBST: getInnoSetupCustomMessages(),
                    ARCHITECTURE_SUBST: args.arch ?: ''
                ])
                filter(FixCrLfFilter,  eol: FixCrLfFilter.CrLf.newInstance('crlf'))
                filteringCharset = 'UTF-8'
            }
            exec {
                // You'd think we could just set the PATH, but there be dragons here
                // https://github.com/palantir/gradle-docker/issues/162
                def exe = exePresent('iscc') ?  'iscc' : file('ci/iscc')
                commandLine exe, "${destinationDir}/OmegaT.iss"
            }
            project.copy {
                from("${destinationDir}/${installerBasename}.exe")
                into(distsDir)
            }
        }
    }
    def signedTaskName = "${args.name}Signed"
    def signedExe = "${distsDir}/${installerBasename}_Signed.exe"
    task(type: Exec, signedTaskName) {
        group = 'omegat distribution'
        // You'd think we could just set the PATH, but there be dragons here
        // https://github.com/palantir/gradle-docker/issues/162
        // Starting from Nov 2022, certification provider force to use HSM to
        // store private keys. Starting on June 1, 2023, at 00:00 UTC, industry
        // standards will require private keys for standard code signing
        // certificates to be stored on hardware certified as FIPS 140 Level 2,
        // Common Criteria EAL 4+, or equivalent.
        // #1179 build/release: Windows binary signature with PKCS#11 HSM
        // https://sourceforge.net/p/omegat/bugs/1179/
        // requires osslsigncode version 2.5 or later.
        onlyIf {
            // Set these in e.g. local.properties
            def props = ['pkcs11module', 'winCodesignPassword']
            conditions([props.every { project.hasProperty(it) }, 'Code signing properties not set'],
                       [file(installerExe).file, 'Unsigned installer not built'],
                       [exePresent('osslsigncode'), 'osslsigncode not installed'])
        }
        inputs.file installerExe
        outputs.file signedExe
        def commandArgs = ['osslsigncode', 'sign', '-pkcs11module', project.hasProperty('pkcs11module')?
                project.property('pkcs11module') : 'dummy(it should specified)']
        if (project.hasProperty('winCodesignCert')) {
            commandArgs.addAll('-certs', project.property('winCodesignCert'))
        }
        if (project.hasProperty('pkcs11cert')) {
            commandArgs.addAll('-pkcs11cert', project.property('pkcs11cert'))
        }
        if (project.hasProperty('winCodesignPassword')) {
            commandArgs.addAll('-pass', project.property('winCodesignPassword'))
        }
        commandArgs.addAll(
                '-t', project.hasProperty('winCodesignTimestampUrl')? project.property('winCodesignTimestampUrl') :
                        'http://time.certum.pl/',
                '-n', applicationName, '-i', omtWebsite, '-h', 'sha256',
                '-in', installerExe.toString(),
                '-out', signedExe.toString())
        commandLine(commandArgs)
        dependsOn args.name
    }
    assemble.dependsOn args.name, signedTaskName
    win.dependsOn args.name, signedTaskName
}
makeWinTask(name: 'winNoJRE', suffix: 'Windows_without_JRE')
makeWinTask(name: 'winJRE64', suffix: 'Windows_64', jrePath: windowsJRE, arch: 'x64')

// Disable .tar distributions for everyone but Linux
tasks.findAll { it.name =~ /[dD]istTar$/ && !it.name.contains('linux') }.each { it.enabled = false }
// Disable .zip distributions for Linux
tasks.findAll { it.name =~ /[dD]istZip$/ && it.name.contains('linux') }.each { it.enabled = false }

processResources {
    def revision = detectRevision()
    inputs.property 'revision', revision
    doLast {
        logger.lifecycle("Detected revision ${revision}")
        def versionFile = file("${sourceSets.main.output.resourcesDir}/org/omegat/Version.properties")
        ant.propertyfile(file: versionFile) {
            entry(key: 'revision', value: revision)
        }
    }
}

task checksums {
    def algos = ['SHA-512', 'MD5']
    description = "Generate ${algos.join(', ')} checksums for distribution files"
    inputs.files fileTree(dir: distsDir, exclude: 'checksums')
    def checksumsDir = file("${distsDir}/checksums")
    outputs.dir checksumsDir
    onlyIf {
        condition(distsDir.directory, 'Distfiles not found')
    }
    doLast {
        distsDir.listFiles().findAll { it.file }.each { f ->
            algos.each { algo ->
                ant.checksum file: f, algorithm: algo, todir: checksumsDir
            }
        }
    }
}

task genJAXB {
    description = 'Generate classes for loading and manipulating XML formats'
}

ext.makeJaxbTask = { args ->
    def taskName = "gen${args.name.capitalize()}"
    task(type: JavaExec, taskName) {
        classpath = configurations.jaxb
        mainClass = 'com.sun.tools.xjc.XJCFacade'
        delegate.args args.args
        outputs.dir args.outdir
    }
    genJAXB.dependsOn taskName
}

makeJaxbTask(name: 'segmentation', outdir: 'src/gen/core/segmentation',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.segmentation', 'src/schemas/srx20.xsd'])
makeJaxbTask(name: 'filters', outdir: 'src/gen/core/filters',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.filters', 'src/schemas/filters.xsd'])
makeJaxbTask(name: 'tbx', outdir: 'src/gen/core/tbx',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.tbx', 'src/schemas/tbx.xsd'])
makeJaxbTask(name: 'project', outdir: 'src/gen/core/project',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.project', 'src/schemas/project_properties.xsd'])
makeJaxbTask(name: 'tmx14', outdir: 'src/gen/core/tmx14',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.tmx14', '-b', 'src/schemas/tmx14.xjb', 'src/schemas/tmx14.xsd'])

task genMac {
    description = 'Generate the Mac .app skeleton. Requires AppBundler (https://bitbucket.org/infinitekind/appbundler) ' +
        'to be available in ~/.ant/lib'
    outputs.dir file('release/mac-specific')
    def appbundlerJar = file("${System.getProperty('user.home')}/.ant/lib/appbundler-1.0ea.jar")
    onlyIf {
        condition(appbundlerJar.file, 'AppBundler not found')
    }
    doLast {
        ant.taskdef(name: 'appbundler',
                    classname: 'com.oracle.appbundler.AppBundlerTask',
                    classpath: appbundlerJar)
        ant.appbundler(outputdirectory: 'release/mac-specific',
                       name: applicationName,
                       displayname: applicationName,
                       executablename: applicationName,
                       identifier: 'org.omegat.OmegaT',
                       icon: 'images/OmegaT.icns',
                       version: '${version}',
                       jvmrequired: javaVersion,
                       shortversion: '${version}',
                       mainclassname: mainClassName) {
            option(value: "-Xdock:name=${applicationName}")
            argument(value: '--config-file=${configfile}')
            bundledocument(extensions: 'project',
                           name: "${applicationName} Project",
                           role: 'editor',
                           icon: 'images/OmegaT.icns')
            bundledocument(extensions: '*',
                           name: 'All Files',
                           role: 'none')
            plistentry(key: 'JVMRuntime', value: 'jre.bundle')
        }
    }
}

task changedOnBranch {
    description = 'List files that have been modified on this git branch.'
    doLast {
        ext.files = project.files(gitModifiedFiles())
        ext.files.each { println(it) }
    }
}

task spotlessChangedApply {
    description = 'Apply code formatting to files that have been changed on the current branch.'
    group = 'omegat workflow'
    finalizedBy 'spotlessApply'
    dependsOn changedOnBranch
    doFirst {
        spotlessJava.target = changedOnBranch.files.findAll {
            it.path.endsWith('.java')
        }
    }
}

jacoco {
    toolVersion="0.8.6"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test) // tests are required to run before generating the report
    group = 'verification'
    reports {
        xml.required = true  // coveralls plugin depends on xml format report
        html.required = true
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: ["gen/core/**/*", "org/omegat/**/gui/*", "org/omegat/**/data/*"])
        }))
    }
}

// check.dependsOn jacocoTestCoverageVerification
tasks.jacocoTestCoverageVerification {
    dependsOn(tasks.test)
    violationRules {
        rule {
            element = 'CLASS'
            includes = ['org.omegat.core.machinetranslators.*', 'org.omegat.core.dictionaries.*']
            excludes = ['**.*.1', '**.*.2', '**.*.3',  // ignore inner classes
                    'org.omegat.core.machinetranslators.MachineTranslators']  // simple plugin reg.
            limit { minimum = 0.20 }
        }
        rule {
            element = 'PACKAGE'
            includes = ['org.omegat.filters?.*',
                        'org.omegat.externalfinder', 'org.omegat.languagetools', 'org.omegat.util',
                        'org.omegat.core.events', 'org.omegat.core.matching', 'org.omegat.core.search',
                        'org.omegat.core.segmentation', 'org.omegat.core.spellchecker', 'org.omegat.core.statistics',
                        'org.omegat.core.tagvalidation', 'org.omegat.core.team2.*']
            excludes = ['org.omegat.core.team2.gui', 'org.omegat.util.xml.*']
            limit { minimum = 0.60 }
        }
    }
}

task manualPdfs {
    description = 'Build PDF manuals for all languages. Requires Docker.'
}

task manualHtmls {
    description = 'Build HTML manuals for all languages. Requires Docker.'
}

ext.manualIndexXmls = fileTree(dir: 'doc_src', include: '**/OmegaTUsersManual_xinclude full.xml')
manualIndexXmls.each { xml ->
    def lang = xml.parentFile.name
    def pdfTaskName = "manualPdf${lang.capitalize()}"
    task(pdfTaskName) {
        inputs.files fileTree(dir: "doc_src/${lang}", include: '**/*.xml')
        outputs.file "${distsDir}/OmegaT_documentation_${lang}.PDF"
        doLast {
            exec {
                workingDir = 'doc_src'
                commandLine './docgen', "-Dlanguage=${lang}", 'pdf'
            }
            copy {
                from fileTree(dir: "doc_src/${lang}/pdf", include: '*.PDF')
                into distsDir
            }
            delete fileTree(dir: "doc_src/${lang}", includes: ['pdf/*', 'index.xml'])
        }
    }
    manualPdfs.dependsOn pdfTaskName

    def htmlTaskName = "manualHtml${lang.capitalize()}"
    task(htmlTaskName) {
        inputs.files fileTree(dir: "doc_src/${lang}", include: '**/*.xml')
        doLast {
            exec {
                workingDir = 'doc_src'
                commandLine './docgen', "-Dlanguage=${lang}", 'html5'
            }
            delete fileTree(dir: "doc_src/${lang}", includes: ['xhtml5/**/*', 'index.xml'])
        }
    }
    manualHtmls.dependsOn htmlTaskName
}

task instantStartGuides {
    description = 'Build Instant Start guides for all languages. Requires Docker.'
}

task firstSteps {
    description = 'Build First Step pages for all languages. Requires Docker.'
}

task updateManuals {
    group = 'omegat release'
    description = 'Update Instant Start guides and HTML manuals.'
    dependsOn manualHtmls, firstSteps, instantStartGuides
    finalizedBy genDocIndex
}

ext.firstStepsXmls = fileTree(dir: 'doc_src', include: '**/First_Steps.xml')
firstStepsXmls.each { xml ->
    def lang = xml.parentFile.name
    def taskName = "firstSteps${lang.capitalize()}"
    task(taskName) {
        inputs.files fileTree(dir: "doc_src/${lang}", include: '**/*.xml')
        doLast {
            exec {
                workingDir = 'doc_src'
                commandLine './docgen', "-Dlanguage=${lang}", 'first-steps'
            }
        }
    }
    firstSteps.dependsOn taskName
}

ext.instantStartXmls = fileTree(dir: 'doc_src', include: '**/InstantStartGuide.xml')
instantStartXmls.each { xml ->
    def lang = xml.parentFile.name
    def taskName = "instantStartGuide${lang.capitalize()}"
    task(taskName) {
        inputs.files fileTree(dir: "doc_src/${lang}", include: '**/*.xml')
        doLast {
            exec {
                workingDir = 'doc_src'
                commandLine './docgen', "-Dlanguage=${lang}", 'instant-start'
            }
        }
    }
    instantStartGuides.dependsOn taskName
}

tasks.getByName("run") {
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED"])
}

task debug(type: JavaExec) {
    description = 'Launch app for debugging.' // Special debug task for NetBeans
    group = 'application'
    mainClass = mainClassName
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs(["--illegal-access=warn"])
    debug true
}

task runOnJava17(type: JavaExec) {
    description = 'Launch app on Java 17'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
    }
    mainClass = application.mainClass
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED"])
    group = 'application'
}

// E.g. when doing `build`, run checks before making distfiles
assemble.mustRunAfter check

test {
    // Test in headless mode with ./gradlew test -Pheadless
    if (project.hasProperty('headless')) {
        systemProperty 'java.awt.headless', 'true'
    }
}

task testIntegration(type: JavaExec) {
    description = 'Run integration tests. Pass repo URL as -Domegat.test.repo=<repo>'
    group = 'omegat workflow'
    mainClass = 'org.omegat.core.data.TestTeamIntegration'
    classpath = sourceSets.testIntegration.runtimeClasspath
    systemProperties = System.properties
}

task testOnJava17(type: Test) {
    description = 'Run test cases on Java 17'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
    }
    if (project.hasProperty('headless')) {
        systemProperty 'java.awt.headless', 'true'
    }
    group = 'verification'
}

ext.mavenStyleVersion = version.replace('_', '-')

publishing {
    publications {
        mavenJava(MavenPublication) { publication ->
            groupId = 'org.omegat'
            artifactId = 'omegat'
            version = mavenStyleVersion
            from components.java

            pom {
                name = 'OmegaT'
                description = 'The free translation memory tool'
                url = 'https://omegat.org'
                scm {
                    connection = "scm:git:https://git.code.sf.net/p/omegat/code"
                    developerConnection = "scm:git:https://git.code.sf.net/p/omegat/code"
                    url = "https://sourceforge.net/p/omegat/code/"
                }
                licenses {
                    license {
                        name = 'The GNU General Public License, Version 3.0'
                        url = 'https://www.gnu.org/licenses/licenses/gpl-3.0.html'
                    }
                }
                developers {
                    developer {
                        id = 'omegat'
                        name = 'OmegaT Developers'
                        email = 'info@omegat.org'
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
            credentials(PasswordCredentials) {
                username findProperty('ossrhUsername')
                password findProperty('ossrhPassword')
            }
        }
    }
}

signing {
    sign publishing.publications.mavenJava
    if (!findProperty("signing.keyId")) {
        useGpgCmd()
    }
}

remotes {
    sourceforgeWeb {
        host = 'web.sourceforge.net'
        user = findProperty('sourceforgeWebUser')
        password = findProperty('sourceforgeWebPassword')
        agent = true
    }
}

ext.htdocs = '/home/project-web/omegat/htdocs'

ext.publishAtomically = { args ->
    task("publish${args.name.capitalize()}") {
        description = "Copy ${args.name} to SourceForge web."
        dependsOn args.sourceTask
        group = 'omegat release'
        doLast {
            ssh.run {
                session(remotes.sourceforgeWeb) {
                    def timestamp = new Date().format('yyyyMMddHHmmss')
                    def targetDir = args.targetDir ?: "${args.name}-${omtFlavor}"
                    def tempDir = "${targetDir}-temp-${timestamp}"
                    sftp {
                        cd htdocs
                        mkdir tempDir
                    }
                    put from: args.sourceTask.outputs.files, into: "${htdocs}/${tempDir}"
                    sftp {
                        cd htdocs
                        try { rename targetDir, "${targetDir}-old-${timestamp}" }
                        catch (ignored) {}
                        rename "${tempDir}/${args.sourceTask.destinationDir.name}", targetDir
                        rmdir tempDir
                    }
                }
            }
        }
    }
}

publishAtomically(name: 'manual', sourceTask: webManual)
publishAtomically(name: 'javadoc', sourceTask: javadoc)

task publishVersion {
    description = 'Update the version considered current by the version check.'
    group = 'omegat release'
    doLast {
        ssh.run {
            session(remotes.sourceforgeWeb) {
                def target = "${htdocs}/Version-${omtFlavor}.properties"
                put from: file('src/org/omegat/Version.properties'), into: target
            }
        }
    }
}

tasks.withType(JavaExec).configureEach {
    // Allow setting the max heap size for the run task from the command line, e.g.
    // `gradle -PrunMaxHeapSize=1024M run`
    maxHeapSize = findProperty('runMaxHeapSize')
    // Ask modules to be up-to-date before run task executed
    dependsOn subprojects.tasks.jar
}

task printVersion {
    println project.version
}

tasks.withType(Copy).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
tasks.withType(Sync).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
tasks.withType(Zip).configureEach {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}
