import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens
import java.nio.file.Paths
import com.github.spotbugs.snom.Confidence

plugins {
    id 'base'
    id 'application'
    id 'java-library'
    id 'java-test-fixtures'
    id 'maven-publish'
    id 'signing'
    id 'eclipse'
    id 'checkstyle'
    id 'jacoco'
    id 'jacoco-report-aggregation'
    alias(libs.plugins.spotbugs)
    alias(libs.plugins.spotless)
    alias(libs.plugins.versions)
    alias(libs.plugins.launch4j)
    alias(libs.plugins.ssh)
}

apply from: 'gradle/utils.gradle'

application {
    applicationName = 'OmegaT'
    mainClass = 'org.omegat.Main'
}

tasks.named('updateDaemonJvm') {
    jvmVersion = JavaVersion.VERSION_17
}

def shortDescription = 'The free translation memory tool'
def distDescription = 'OmegaT is a free and open source multiplatform Computer Assisted Translation tool with' +
        ' fuzzy matching, translation memory, keyword search, glossaries, and translation leveraging into updated' +
        ' projects.'
def distAppVendor = 'The OmegaT project'
def gradleOnJava17OrLater = JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17)
def javaVersion = 11;
def localPropsFile = file('local.properties')
ext {
    omtVersion = loadProperties(file('src/org/omegat/Version.properties'))
    if (localPropsFile.file) {
        loadProperties(localPropsFile).each { k, v ->
            if (!findProperty(k)) {
                set(k, v)
            }
        }
    }
    providedLibsDir = file('lib/provided')
}
def omtFlavor = omtVersion.beta.empty ? 'standard' : 'latest'
def omtWebsite = 'https://omegat.org'
def envIsCi = project.hasProperty('envIsCi') as Boolean

version = omtVersion.version + getUpdateSuffix(omtVersion.update)

java {
    withSourcesJar()
    withJavadocJar()
}

allprojects {
    apply plugin: 'checkstyle'
    apply plugin: 'java-library'
    apply plugin: 'eclipse'
    apply plugin: 'com.github.spotbugs'
    apply plugin: 'com.diffplug.spotless'
    apply plugin: 'jacoco'

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(javaVersion)
            vendor = JvmVendorSpec.ADOPTIUM
        }
    }

    javadoc {
        failOnError = false
        options {
            jFlags('-Duser.language=en')
            addStringOption('locale', 'en_US')
            addStringOption('bottom', '<span>Copyright 2000-2023, OmegaT project and contributors</span>')
            addStringOption('encoding', 'UTF-8')
            addBooleanOption("Xdoclint:none", true)
            addBooleanOption('html5', true)
            addBooleanOption('frames', false)
            addBooleanOption('public', true)
        }
    }
    tasks.withType(JavaCompile) {
       options.encoding = "UTF-8"
       options.compilerArgs.addAll '-Xlint', '-Werror'
    }

    sourcesJar {
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }

    spotbugs {
        reportLevel = Confidence.valueOf('HIGH')
    }

    tasks.register('spotbugsMainReport') {
        def reportFile = file("build/reports/spotbugs/main.txt")
        doLast {
            if (reportFile.exists()) {
                println()
                reportFile.readLines().forEach {
                    println(it)
                }
            }
        }
        group = 'verification'
    }

    tasks.register('spotbugsTestReport') {
        def reportFile = file("build/reports/spotbugs/test.txt")
        doLast {
            if (reportFile.exists()) {
                println()
                reportFile.readLines().forEach {
                    println(it)
                }
            }
        }
        group = 'verification'
    }

    spotbugsMain {
        if (envIsCi) {
            extraArgs = ['-longBugCodes']
            jvmArgs = ['-Duser.language=en']
        }
        reports {
            text.required = envIsCi
            html.required = !envIsCi
        }
        finalizedBy(spotbugsMainReport)
    }

    spotbugsTest {
        if (envIsCi) {
            extraArgs = ['-longBugCodes']
            jvmArgs = ['-Duser.language=en']
        }
        reports {
            text.required = envIsCi
            html.required = !envIsCi
        }
        finalizedBy(spotbugsTestReport)
    }

    checkstyle {
        toolVersion = libs.versions.checkstyle.get()
    }
    checkstyleMain.exclude '**/gen/**'

    spotless {
        enforceCheck false
        java {
            targetExclude 'src/gen/**'
            eclipse().configFile file("${rootDir}/config/spotless/eclipse-formatting.xml")
            removeUnusedImports()
        }
    }

    repositories {
        mavenCentral()
        mavenLocal()
        // Sonatype OSSRH snapshots
        maven { url "https://s01.oss.sonatype.org/content/repositories/snapshots" }
        maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
    }
}

sourceSets {
    main {
        java {
            srcDir 'src'
        }
        resources {
            srcDir 'src'
        }
    }
    test {
        java {
            srcDir 'test/src'
        }
        resources {
            srcDir 'test/src'
            srcDir 'test/data'
        }
    }
    testFixtures {
        java {
            srcDir 'test/fixtures'
        }
    }
    testAcceptance {
        java {
            compileClasspath += main.output + test.output
            runtimeClasspath += main.output + test.output
            srcDir 'test-acceptance/src'
        }
    }
    testIntegration {
        java {
            srcDir 'test-integration/src'
        }
    }
}

configurations {
    all
    [testRuntime, testCompile]*.exclude group: 'org.languagetool', module: 'language-all'
    testIntegrationImplementation.extendsFrom implementation
    testAcceptanceImplementation.extendsFrom testImplementation
    testAcceptanceRuntime.extendsFrom testRuntime
    jaxb
    genMac
}

ext {
    providedLibsDir = file('lib/provided')
}

dependencies {
    // Libs are provided in the "source" distribution only
    if (providedLibsDir.directory) {
        implementation fileTree(dir: providedLibsDir, include: '**/*.jar', excludes: ['**/slf4j-api-1.*.jar'])
    } else {
        implementation(libs.commons.io)
        implementation(libs.commons.lang3)
        implementation(libs.commons.validator)
        api(libs.slf4j.api)
        implementation(libs.slf4j.format.jdk14)
        runtimeOnly(libs.slf4j.jdk14)

        // macOS integration
        implementation(libs.madlonkay.desktopsupport)

        // stax
        implementation(libs.stax2.api)
        runtimeOnly(libs.woodstox.core)

        // Data: inline data URL handler
        implementation(libs.url.protocol.handler)

        // PDF Filter
        implementation(libs.apache.pdfbox)

        // Dictionary
        implementation(libs.bundles.dictionary)

        // Encoding detections
        implementation(libs.juniversal.chardet)

        // Legacy projects re-hosted on Maven Central
        api(libs.omegat.vldocking)
        implementation(libs.omegat.htmlparser)
        implementation(libs.omegat.gnudiff4j)
        implementation(libs.omegat.mnemonics)

        // LanguageTool
        implementation(libs.languagetool.core) {
            exclude module: 'guava'
            exclude module: 'language-detector'
            exclude group: 'com.google.android'
        }
        implementation(libs.language.detector)

        runtimeOnly(libs.languagetool.all) {
            // Temporary exclusion; see https://sourceforge.net/p/omegat/bugs/814/
            exclude module: 'lucene-gosen'
            exclude module: 'language-detector'
        }
        runtimeOnly 'org.omegat.lucene:lucene-gosen:5.5.1:ipadic'

        // Lucene for tokenizers
        implementation(libs.bundles.lucene)

        // Team project server support
        implementation(libs.bundles.jgit)

        // For ed25519 and ecdsa support of ssh, java16+ or BC
        implementation(libs.bundles.ecdsa)

        // For gpg signing
        implementation(libs.jgit.bc)

        // For subversion
        implementation(libs.svnkit) {
            exclude module: 'sshd-core'
            exclude module: 'sshd-common'
        }

        // Team project conflict resolution
        implementation(libs.madlonkay.supertmxmerge)

        // Credentials encryption
        implementation(libs.jasypt)

        // Groovy used for scripts - needed at implementation for GroovyClassLoader modifications
        // Ivy is needed to handle Grape/@Grab dependencies
        runtimeOnly(libs.bundles.groovy)

        // Javascript used for scripts
        implementation(libs.nashorn.core)

        // Script editor
        implementation(libs.bundles.fifesoft) {
            exclude module: 'rhino'
        }

        implementation(libs.guava)
        implementation(libs.jetbrains.annotations)

        // JSON parser
        implementation(libs.bundles.jackson)

        implementation(libs.jetbrains.annotations)

        implementation(libs.bundles.caffeine) {
            attributes {
                attribute(Bundling.BUNDLING_ATTRIBUTE, project.objects.named(Bundling.class, Bundling.EXTERNAL))
            }
        }

        // Platform integration with Windows and macOS
        implementation(libs.jna)
        implementation(libs.jfa) {
            exclude module: 'jna'
        }
    }

    // Test dependencies

    testFixturesApi(libs.junit4)
    // for http connection test
    testFixturesApi(libs.wiremock) {
        exclude module: 'guava'
    }
    testFixturesApi(libs.slf4j.api)
    testFixturesImplementation(libs.commons.io)
    testFixturesImplementation(libs.omegat.vldocking)
    testFixturesImplementation(libs.assertj.swing.junit)

    testImplementation(libs.assertj)
    testImplementation(libs.bundles.xmlunit)
    // LanguageTool unit tests exercise these languages
    testImplementation(libs.bundles.languagetool.tests) {
        exclude group: 'org.slf4j'
        exclude module: 'guava'
        exclude module: 'language-detector'
        exclude group: 'ch.qos.logback'
        // Temporary exclusion; see https://sourceforge.net/p/omegat/bugs/814/
        exclude module: 'lucene-gosen'
    }
    testImplementation "org.omegat.lucene:lucene-gosen:5.5.1:ipadic"
    testRuntimeOnly(libs.slf4j.jdk14)

    // JAXB codegen only
    jaxb(libs.jaxb.xjc)

    // genMac only
    genMac(libs.omegat.appbundler)

    testAcceptanceImplementation sourceSets.main.output
    testAcceptanceImplementation(libs.commons.io)
    testAcceptanceImplementation(libs.slf4j.jdk14)
    testAcceptanceImplementation(libs.slf4j.format.jdk14)
    testAcceptanceImplementation(testFixtures(project.rootProject))
    testAcceptanceImplementation(libs.assertj.swing.junit)
    testAcceptanceImplementation(libs.bundles.jackson)

    testIntegrationImplementation sourceSets.main.output, sourceSets.test.output
    testIntegrationImplementation(testFixtures(project.rootProject))
    testIntegrationRuntimeOnly(libs.slf4j.jdk14)

    jacocoAggregation project(':aligner')
    jacocoAggregation project(":machinetranslators:apertium")
    jacocoAggregation project(":machinetranslators:belazar")
    jacocoAggregation project(":machinetranslators:deepl")
    jacocoAggregation project(":machinetranslators:google")
    jacocoAggregation project(":machinetranslators:ibmwatson")
    jacocoAggregation project(":machinetranslators:mymemory")
    jacocoAggregation project(":machinetranslators:yandex")
}

jar {
    def omtPlugins = loadProperties(file('Plugins.properties'))
    manifest {
        attributes('License': 'GNU Public License version 3 or later',
                   'Implementation-Version': project.version,
                   'Permissions': 'all-permissions',
                   'OmegaT-Plugin': 'true',
                   'OmegaT-Plugins': omtPlugins.plugin,
                   'Plugin-Author': 'OmegaT team',
                   'Plugin-Link': 'https://omegat.org',
                   'Plugin-Version': project.version,
                   'Main-Class': application.mainClass,
                   'Class-Path': configurations.runtimeClasspath.collect { "lib/${it.name}" }.join(' '))
        ext.pluginAttr = { name, path, category, description ->
            attributes('Plugin-Name': name, 'Plugin-Category': category, 'Plugin-Description': description, path)
        }
        def desc = [:]
        omtPlugins.each { key, val ->
            if (key.startsWith('plugin.desc')) {
                desc[key.split('\\.').last()] = val
            } else if (key != 'plugin') {
                val.tokenize().each { cls ->
                    attributes('OmegaT-Plugin': key, cls)
                }
            }
        }
        pluginAttr('Dictionary driver[bundle]', 'org/omegat/core/dictionaries/', 'dictionary', desc.dictionary)
        pluginAttr('File filters[bundle]', 'org/omegat/filters2/', 'filter', desc.filters2)
        pluginAttr('XML filters[bundle]', 'org/omegat/filters3/', 'filter', desc.filters3)
        pluginAttr('New XML filters[bundle]', 'org/omegat/filters4/', 'filter', desc.filters4)
        pluginAttr('Tokenizers[bundle]', 'org/omegat/tokenizer/', 'tokenizer', desc.tokenizer)
        pluginAttr('Themes [bundle]', 'org/omegat/gui/theme/', 'theme', desc.theme)
        pluginAttr('Scripting engine', 'org/omegat/gui/script/', 'miscellaneous', desc.script)
        pluginAttr('GUI extensions', 'org/omegat/util/gui/', 'miscellaneous', desc.guiutil)
        pluginAttr('Local external search', 'org/omegat/externalfinder/', 'miscellaneous', desc.externalfinder)
        pluginAttr('Repository connector', 'org/omegat/core/team2/impl/', 'repository', desc.repository)
    }
    // Don't include extra stuff like version number in JAR name
    archiveFileName.set("${archiveBaseName.get()}.${archiveExtension.get()}")
}

def omegatJarFilename = jar.archiveFileName.get()
project(":machinetranslators") {jar.enabled = false}
project(":spellchecker") {jar.enabled = false}

def assetDir = findProperty('assetDir') ?: '../'
def macJRE = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_x64_mac_*.tar.gz')
def armMacJRE = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_aarch64_mac_*.tar.gz')
def linux64JRE = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_x64_linux_*.tar.gz')
def linuxArm64JRE = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_aarch64_linux_*.tar.gz')
def windowsJRE32 = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_x86-32_windows_*.zip')
def windowsJRE = fileTree(dir: assetDir, include: 'OpenJDK17U-jre_x64_windows_*.zip')

/*
 * Configuration of launch4j java launcher.
 * OmegaT uses it as launcher for windows.
 */
launch4j {
    libraryDir = "." // assume OmegaT.jar is located as same folder as OmegaT.exe
    dontWrapJar = true
    downloadUrl = 'https://adoptium.net/'
    supportUrl = 'https://omegat.org/support'
    icon = "${projectDir}/images/OmegaT.ico"
    errTitle = 'OmegaT'
    headerType = 'gui'
    jreMinVersion = '11.0'
    jreMaxVersion = '21.1'
    copyConfigurable = [] // hack: don't copy dependencies to $libraryDir
    // assume bundled JRE in jre/, fallback to JAVA_HOME env then PATH
    bundledJrePath = 'jre;%JAVA_HOME%;%PATH%'
    requires64Bit = false  // support 32bit distribution
    copyright = "The GNU General Public License, Version 3.0"
    version = omtVersion.version
    textVersion = omtVersion.version
    companyName = distAppVendor
    fileDescription = shortDescription
    restartOnCrash = false
    stayAlive = false
    priority = 'normal'
}

tasks.register('manualZips') {
    description = 'Build ZIP manuals to bundle into application. Requires container runtime.'
    group = 'documentation'
}

tasks.register('manualPdfs') {
    description = 'Build PDF manuals for all languages. Requires container runtime.'
    group = 'documentation'
}

tasks.register('manualHtmls') {
    description = 'Build HTML manuals and zip for all languages. Requires container runtime.'
    group = 'documentation'
}

tasks.register('genDocIndex', Copy) {
    def docPropsFiles = fileTree(dir: 'doc_src', include: '*/version*.properties').findAll {
        file("${it.parent}/OmegaTUsersManual_xinclude full.xml").file }
    def langNameExceptions = loadProperties(file('doc_src/lang_exceptions.properties'))
    def langInfos = docPropsFiles.toSorted{ it.parentFile.name }.collect { props ->
        def docVersion = loadProperties(props).version
        ['code': props.parentFile.name, 'nomanual': false, 'version': docVersion,
         'name': langNameExceptions[props.parentFile.name] ?:
                 Locale.forLanguageTag(props.parentFile.name.replace('_', '-')).getDisplayName(),
         'status': docVersion == omtVersion.version ? 'up-to-date' : 'out-of-date'] }
    def inputTemplate = file('doc_src/index_template.html')
    def outputIndex = layout.buildDirectory.file("docs/manual/index.html").get().asFile
    description = 'Generate the docs index file'
    inputs.files docPropsFiles, inputTemplate
    outputs.files file(outputIndex)
    from inputTemplate
    into outputIndex.parent
    rename('index_template.html', 'index.html')
    expand('languages': langInfos)
    filteringCharset = 'UTF-8'
    dependsOn manualHtmls
    group = 'documentation'
}

tasks.register('webManual', Sync) {
    group = 'documentation'
    description = 'Sync the HTML manual files'
    dependsOn manualHtmls, genDocIndex
    destinationDir file(layout.buildDirectory.file("docs/htdocs"))
    from file(layout.buildDirectory.file("docs/manual"))
    from('release') {
        include 'doc-license.txt'
    }
}

ext.manualIndexXmls = fileTree(dir: 'doc_src', include: '**/OmegaTUsersManual_xinclude full.xml')
manualIndexXmls.each { xml ->
    def lang = xml.parentFile.name
    def pdfTaskName = "manualPdf${lang.capitalize()}"
    tasks.register(pdfTaskName, Exec) {
        inputs.files fileTree(dir: "doc_src/${lang}", includes: ['**/*.xml', 'images/*.png'],
                excludes: ['xhtml5/*', 'index.xml'])
        outputs.files layout.buildDirectory.file("docs/pdfs/OmegaT_documentation_${lang}.PDF")
        onlyIf {
            conditions([exePresent('docker') || exePresent('nerdctl'), 'Docker or nerdctl is not installed'],
                    [!project.hasProperty('forceSkipDocumentBuild'), 'Specified forceSkipDocumentBuild property'])
        }
        workingDir = 'doc_src'
        commandLine './docgen', "-Dlanguage=${lang}", "-Dtarget=../build/docs/pdfs", 'pdf'
        doLast {
            delete fileTree(dir: "doc_src/${lang}", includes: ['pdf/*', 'index.xml'])
        }
    }
    manualPdfs.dependsOn pdfTaskName

    def htmlTaskName = "manualHtml${lang.capitalize()}"
    tasks.register(htmlTaskName, Exec) {
        inputs.files fileTree(dir: "doc_src/${lang}", includes: ['**/*.xml', 'images/*.png'],
                excludes: ['xhtml5/*', 'index.xml'])
        outputs.files fileTree(dir: layout.buildDirectory.file("docs/manual/${lang}/"),
                includes: ['*.html', 'OmegaT.css', 'images/*.png', '_wh/**/*.js', '_wh/wh.css'])
        onlyIf {
            conditions([exePresent('docker') || exePresent('nerdctl'), 'Docker or nerdctl is not installed'],
                [!project.hasProperty('forceSkipDocumentBuild'), 'Specified forceSkipDocumentBuild property'])
        }
        workingDir = 'doc_src'
        commandLine './docgen', "-Dlanguage=${lang}", "-Dtarget=../build/docs/manual/${lang}", 'html5'
    }
    manualHtmls.dependsOn htmlTaskName

    def zipTaskName="manualZip${lang.capitalize()}"
    def versionProperties = loadProperties(file("doc_src/${lang}/version_${lang}.properties"))
    if (lang.equals("en") || versionProperties.version.equals(omtVersion.version)) {
        tasks.register(zipTaskName, Zip) {
            from fileTree(dir: layout.buildDirectory.file("docs/manual/${lang}"))
            exclude 'docs/manual/index.html'
            from fileTree(dir: "doc_src/${lang}", include: '**/version*.properties')
            archiveFileName = "${lang}.zip"
            destinationDirectory = file("${buildDir}/docs/manuals/")
        }
        manualZips.dependsOn zipTaskName
        tasks.getByName(zipTaskName).dependsOn htmlTaskName
    }
}

tasks.register('firstSteps') {
    description = 'Build First pages for all languages at docs/greetings/. Requires Docker.'
    group = 'documentation'
}

tasks.register('updateManuals') {
    group = 'documentation'
    description = 'Update Instant Start guides and HTML manuals.'
    dependsOn manualHtmls, firstSteps, genDocIndex
}

ext.firstStepsXmls = fileTree(dir: 'doc_src', include: '**/First_Steps.xml')
firstStepsXmls.each { xml ->
    def lang = xml.parentFile.name
    def taskName = "firstSteps${lang.capitalize()}"
    tasks.register(taskName, Exec) {
        inputs.files fileTree(dir: "doc_src/${lang}", include: 'First_Steps.xml')
        outputs.files fileTree(dir: layout.buildDirectory.file('docs/greetings/'),
                includes: ["${lang}/first_steps.html", "${lang}/OmegaT.css"])
        onlyIf {
            conditions([exePresent('docker') || exePresent('nerdctl'), 'Docker or nerdctl is not installed'],
                    [!project.hasProperty('forceSkipDocumentBuild'), 'Specified forceSkipDocumentBuild property'])
        }
        workingDir = 'doc_src'
        commandLine './docgen', "-Dlanguage=${lang}", "-Dtarget=../build/docs/greetings/${lang}", 'first-steps'
    }

    firstSteps.dependsOn taskName
}

ext.instantStartXmls = fileTree(dir: 'doc_src', include: '**/InstantStartGuide.xml')
instantStartXmls.each { xml ->
    def lang = xml.parentFile.name
    def taskName = "instantStartGuide${lang.capitalize()}"
    tasks.register(taskName, Exec) {
        inputs.files fileTree(dir: "doc_src/${lang}", includes: ['InstantStartGuide.xml', '**/InstantGuide*png'])
        outputs.files fileTree(dir: layout.buildDirectory.file('docs/greetings/'),
                includes: ["${lang}/first_steps.html", "${lang}/images/InstantGuide*png", "${lang}/OmegaT.css"])
        onlyIf {
            conditions([exePresent('docker') || exePresent('nerdctl'), 'Docker or nerdctl is not installed'],
                    [!project.hasProperty('forceSkipDocumentBuild'), 'Specified forceSkipDocumentBuild property'])
        }
        workingDir = 'doc_src'
        commandLine './docgen', "-Dlanguage=${lang}", "-Dtarget=../build/docs/greetings/${lang}", 'instant-start'
    }
    firstSteps.dependsOn taskName
}

tasks.register('genMac') {
    def appbundlerClasspath = configurations.genMac.asPath
    def outDir = layout.buildDirectory.file("appbundler").get().toString()
    def appName = application.applicationName
    def appClass = application.mainClass.get()
    description = 'Generate the Mac .app skeleton. Depends AppBundler (https://github.com/TheInfiniteKind/appbundler)'
    outputs.dir layout.buildDirectory.file("appbundler")
    doLast {
        ant.taskdef(name: 'appbundler',
                classname: 'com.oracle.appbundler.AppBundlerTask',
                classpath: appbundlerClasspath)
        ant.appbundler(outputdirectory: outDir,
                name: appName,
                displayname: appName,
                executablename: appName,
                identifier: 'org.omegat.OmegaT',
                icon: 'images/OmegaT.icns',
                version: '${version}',
                jvmrequired: '${jvmRequired}',
                shortversion: '${version}',
                mainclassname: appClass) {
            option(value: "-Xdock:name=${appName}")
            option(value: "-Dapple.awt.application.name=${appName}")
            option(value: "-Dapple.awt.application.appearance=system")
            argument(value: '--config-file=${configfile}')
            bundledocument(extensions: 'project',
                    name: "${appName} Project",
                    role: 'editor',
                    icon: 'images/OmegaT.icns')
            bundledocument(extensions: '*',
                    name: 'All Files',
                    role: 'none')
            plistentry(key: 'JVMRuntime', value: 'jre.bundle')
        }
    }
}

distributions {
    main {
        contents {
            // docs targets
            // /docs
            // ...../greetings/<lang>/first_steps.html
            // ...../manuals/<lang>.zip
            from('release') {
                into 'docs'
                include 'doc-license.txt'
                filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            }
            from('release') {
                // ** Caution!! **
                // 'readme*.txt' and 'changes.txt' are expected
                // in releases/win32-specific/OmegaT.iss
                // 'contributors.txt' and 'libraries.txt' are expected
                // in org.omegat.gui.dialogs.AboutDialog#getContributors
                // and org.omegat.gui.dialogs.AboutDialog#getLibraries
                exclude 'doc-license.txt'
                include '*.txt', '*.html'
                filter(ReplaceTokens, tokens: [
                        TRANSLATION_NOTICE: ''
                ])
                filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            }
            project.tasks.matching {it.name.startsWith('firstSteps') || it.name.startsWith('instantStart')}.forEach {
                from(it.outputs) { into 'docs/greetings' }
            }
            project.tasks.matching {it.name.startsWith('manualZip')}.forEach {
                from(it.outputs) { into 'docs/manuals' }
            }
            from('scripts') {
                into 'scripts'
            }
            from('images') {
                into 'images'
            }
            from('release/plugins-specific') {
                into 'plugins'
            }
            from('release/linux-specific') {
                filter ReplaceTokens, tokens: [
                        VERSION_NUMBER_SUBST: project.version,
                        JAR_SUBST           : omegatJarFilename
                ]
                fileMode 0755
            }
            from('release/win32-specific') {
                include 'OmegaT.bat'
                filter(ReplaceTokens, tokens: [
                        JAR_SUBST           : omegatJarFilename
                ])
            }
            from('lib/licenses') {
                into 'lib'
            }
            // system core plugins into modules
            from('releases/modules-specific') {
                into 'modules'
            }
            from(subprojects.collect {it.tasks.withType(Jar)}) {
                into 'modules'
            }
            eachFile {
                // Move main JAR up one level from lib.
                if (it.name == omegatJarFilename) {
                    it.relativePath = it.relativePath.parent.parent.append(true, omegatJarFilename)
                }
            }
        }
        distZip.archiveFileName.set("${application.applicationName}_${version}${omtVersion.beta}_Without_JRE.zip")
    }

    source {
        contents {
            from(rootDir) {
                include 'config/**', 'ci/iscc', 'ci/osslsigncode', 'images/**', 'lib/**', 'release/**',
                    'src/**/*.java', 'test/**', 'test-integration/**', 'doc_src/**', 'docs_devel/**', 'scripts/**',
                    'gradle/**', 'gradle*', 'build.gradle', 'settings.gradle', 'README.md', '*.properties',
                    'tipoftheday/**', 'machinetranslators/**', 'scriptengine/**', 'LICENSE', 'compose.yml',
                    '.checkstyle'
                exclude '**/build/**', 'doc_src/**/pdf/**', 'doc_src/**/xhtml5/**', 'local.properties', '**/out/**'
            }
            from(processResources) {
                into('src')
            }
            into('lib/provided') {
                // collect project runtime dependencies in all subprojects and sourceSets
                from configurations.runtimeClasspath
                from {subprojects.findAll { it.getSubprojects().isEmpty()}
                        .collect { it.configurations.matching { it.name.endsWith('untimeClasspath')
                                && !it.name.startsWith('test') && !it.name.startsWith('jaxb')
                        } }
                }
           }
        }
        sourceDistZip.archiveFileName.set(
                "${application.applicationName}_${project.version}${omtVersion.beta}_Source.zip")
    }
}

def hunspellJar = configurations.runtimeClasspath.files.find {
    it.name.startsWith('hunspell')
}

tasks.register('hunspellJarSignedContents', Sync) {
    onlyIf {
        // Set this in e.g. local.properties
        conditions([project.hasProperty('macCodesignIdentity'), 'Code signing property not set'],
                [exePresent('codesign'), 'codesign command is not present in system.'])
    }
    from zipTree(hunspellJar)

    destinationDir file(layout.buildDirectory.file("hunspell"))
    doLast {
        def dylibs = fileTree(dir: destinationDir, include: '**/*.dylib').files
        exec {
            commandLine('codesign', '--deep', '--force',
                    '--sign', project.property('macCodesignIdentity'),
                    '--timestamp',
                    '--options', 'runtime',
                    '--entitlements', file('release/mac-specific/java.entitlements'),
                    *dylibs.toList())
        }
    }
}

tasks.register('hunspellSignedJar', Jar) {
    from hunspellJarSignedContents.outputs
    archiveFileName.set(hunspellJar.name)
}

tasks.register('mac') {
    description = 'Build the Mac distributions.'
    group = 'omegat distribution'
}

ext.makeMacTask = { args ->
    def installTaskName = 'install' + args.name.capitalize()  + "Dist"
    def signedInstallTaskName = 'install' + args.name.capitalize() + "SignedDist"
    def distZipTaskName = args.name + "DistZip"
    def signedZipTaskName = args.name + "Signed"
    def notarizeTaskName = args.name + "Notarize"
    def stapledNotarizedDistZipTaskName = args.name + "StapledNotarized"

    tasks.register(distZipTaskName, Zip) {
        description = "Create Mac distribution for ${args.name}"
        // mac specific contents
        from(genMac.outputs) {
            exclude '**/MacOS/OmegaT', '**/Info.plist', '**/java.entitlements'
        }
        from(genMac.outputs) {
            include '**/MacOS/OmegaT'
            fileMode 0755
        }
        from(genMac.outputs) {
            include '**/Info.plist'
            expand(version: project.version,
                    jvmRequired: '11+',
                    // when bundled JRE, path 'jre.bundle', otherwise 'default'
                    jreRuntime: args.jrePath ? 'jre.bundle' : 'default',
                    // $APP_ROOT is expanded at runtime by the launcher binary
                    configfile: '$APP_ROOT/Contents/Resources/Configuration.properties')
        }
        into('OmegaT.app/Contents/Java') {
            with distributions.main.contents
            exclude '*.sh', '*.kaptn', 'OmegaT', 'OmegaT.bat', 'omegat.desktop', '*.exe'
        }
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
        archiveFileName.set("${application.applicationName}_${project.version}${omtVersion.beta}_${args.suffix}.zip")
        if (args.jrePath && !args.jrePath.empty) {
            from(tarTree(args.jrePath.singleFile)) {
                into 'OmegaT.app/Contents/PlugIns'
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre.bundle')
                }
            }
        }
        outputs.upToDateWhen {
            // detect up-to-date when OmegaT.jar exists and newer than libs/OmegaT.jar
            def f1 = base.distsDirectory.file(archiveFileName).get().asFile
            def f2 = base.libsDirectory.file('OmegaT.jar').get().asFile
            f1.exists() && f2.exists() && f1.lastModified() > f2.lastModified()
        }
        onlyIf {
            condition(!args.jrePath || !args.jrePath.empty, 'JRE not found')
        }
        group = 'omegat distribution'
    }
    mac.dependsOn distZipTaskName
    assemble.dependsOn distZipTaskName

    tasks.register(installTaskName, Sync) {
        description = 'Build a Mac distribution.'
        onlyIf {
            condition(!args.jrePath || !args.jrePath.empty, 'JRE not found')
        }
        // mac specific contents
        from(genMac.outputs) {
            exclude '**/MacOS/OmegaT', '**/Info.plist', '**/java.entitlements'
        }
        from(genMac.outputs) {
            include '**/MacOS/OmegaT'
            fileMode 0755
        }
        from(genMac.outputs) {
            include '**/Info.plist'
            expand(version: project.version,
                    jvmRequired: '11+',
                    // $APP_ROOT is expanded at runtime by the launcher binary
                    configfile: '$APP_ROOT/Contents/Resources/Configuration.properties')
        }
        into('OmegaT.app/Contents/Java') {
            with distributions.main.contents
            exclude '*.sh', '*.kaptn', 'OmegaT', 'OmegaT.bat', 'omegat.desktop', '*.exe'
        }
        if (args.jrePath && !args.jrePath.empty) {
            from(tarTree(args.jrePath.singleFile)) {
                into 'OmegaT.app/Contents/PlugIns'
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre.bundle')
                }
            }
        }
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
        destinationDir  file(layout.buildDirectory.file("install/${application.applicationName}-${args.suffix}"))
        outputs.upToDateWhen {
            // detect up-to-date when OmegaT.jar exists and newer than libs/OmegaT.jar
            def f1 = file("$destinationDir/OmegaT.app/Contents/Java/OmegaT.jar")
            def f2 = base.libsDirectory.file('OmegaT.jar').get().asFile
            f1.exists() && f2.exists() && f1.lastModified() > f2.lastModified()
        }
        doFirst {
            delete "$destinationDir/OmegaT.app/Contents/PlugIns/jre.bundle"
        }
        group = 'distribution'
        dependsOn hunspellSignedJar
    }

    tasks.register(signedInstallTaskName, Sync) {
        description = 'Build a signed Mac distribution. Requires an Apple Developer Account.'
        onlyIf {
            // Set this in e.g. local.properties
            conditions([project.hasProperty('macCodesignIdentity'), 'Code signing property not set'],
                       [args.jrePath && !args.jrePath.empty, 'JRE not found'],
                       [exePresent('codesign'), 'codesign command is not present in system.'])
        }
        from(tasks.getByName(installTaskName).outputs)
        from(hunspellSignedJar.outputs) {
            into 'OmegaT.app/Contents/Java/lib'
        }
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
        destinationDir file(layout.buildDirectory.file("install/${application.applicationName}-${args.suffix}_Signed"))
        doFirst {
            delete "$destinationDir/OmegaT.app/Contents/PlugIns/jre.bundle"
        }
        doLast {
            exec {
                commandLine 'codesign', '--deep', '--force',
                        '--sign', project.property('macCodesignIdentity'),
                        '--timestamp',
                        '--options', 'runtime',
                        '--entitlements', file('release/mac-specific/java.entitlements'),
                        file("${destinationDir}/OmegaT.app")
            }
        }
        group = 'distribution'
        dependsOn hunspellSignedJar
    }

    tasks.register(signedZipTaskName, Zip) {
        def zipRoot = "${application.applicationName}_${project.version}${omtVersion.beta}_${args.suffix}_Signed"
        from tasks.getByName(signedInstallTaskName).outputs
        into zipRoot
        archiveFileName.set("${zipRoot}.zip")
        group = 'omegat distribution'
        dependsOn signedInstallTaskName
    }

    tasks.register(notarizeTaskName, Exec) {
        onlyIf {
            conditions([project.hasProperty('macNotarizationUsername'), 'Username for notarization not set'],
                    [exePresent('xcrun'), 'XCode is not present in system.'])
        }
        inputs.files tasks.getByName(signedZipTaskName).outputs.files
        doLast {
            exec {
                // Assuming setup per instructions at
                // https://developer.apple.com/documentation/security/notarizing_your_app_before_distribution/customizing_the_notarization_workflow#3087734
                commandLine 'xcrun', 'altool', '--notarize-app',
                        '--primary-bundle-id', "org.omegat.$version",
                        '--username', project.property('macNotarizationUsername'),
                        '--password', '@keychain:AC_PASSWORD',
                        '--file', inputs.files.singleFile
            }
        }
        dependsOn signedZipTaskName
    }

    tasks.register(stapledNotarizedDistZipTaskName, Zip) {
        def zipRoot = "${application.applicationName}_${project.version}${omtVersion.beta}_${args.suffix}_Notarized"
        from tasks.getByName(signedInstallTaskName).outputs
        into zipRoot
        onlyIf {
            condition(exePresent('xcrun'), 'XCode is not present in system.')
        }
        doFirst {
            if (args.name.equals("mac")) {
                exec {
                    commandLine 'xcrun', 'stapler', 'staple', "${macInstallSignedDist.destinationDir}/OmegaT.app"
                }
            } else {
                exec {
                    commandLine 'xcrun', 'stapler', 'staple', "${armMacInstallSignedDist.destinationDir}/OmegaT.app"
                }
            }
        }
        archiveFileName.set("${zipRoot}.zip")
        dependsOn signedInstallTaskName
    }
}
makeMacTask(name: 'macX64', suffix: 'Mac_x64', jrePath: macJRE)
makeMacTask(name: 'macArm', suffix: 'Mac_arm', jrePath: armMacJRE)

tasks.register('linux') {
    description = 'Build the Linux distributions.'
    group = 'omegat distribution'
}

ext.makeLinuxTask = { args ->
    def distTaskName = "install" + args.name.capitalize() + "Dist"
    def tarTaskName = args.name + "DistTarBz"
    tasks.register(distTaskName, Sync) {
        group = 'distribution'
        description = "Create a linux installDist for ${args.name}. "
        with distributions.main.contents
        destinationDir file(layout.buildDirectory.file("install/${application.applicationName}-${args.suffix}"))
        onlyIf {
            condition(!args.jrePath.empty, 'ARM64 JRE not found')
        }
        doFirst {
            delete "$destinationDir/jre"
        }
        if (args.jrePath && !args.jrePath.empty) {
            from(tarTree(args.jrePath.singleFile)) {
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                }
            }
        }
    }
    tasks.register(tarTaskName, Tar) {
        description = "Create a Linux distribution for ${args.name}. "
        with distributions.main.contents
        onlyIf {
            condition(!args.jrePath.empty, 'ARM64 JRE not found')
        }
        if (args.jrePath && !args.jrePath.empty) {
            from(tarTree(args.jrePath.singleFile)) {
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                }
            }
        }
        application {
            archiveFileName.set("${applicationName}_${project.version}${omtVersion.beta}_${args.suffix}.tar.bz2")
        }
        compression = Compression.BZIP2
        archiveExtension = 'tar.bz2'
        group = 'omegat distribution'
    }
    assemble.dependsOn tarTaskName
    linux.dependsOn tarTaskName
}
makeLinuxTask(name: "linux64", suffix: "Linux_64", jrePath: linux64JRE)
makeLinuxTask(name: "linuxArm64", suffix: "Linux_ARM64", jrePath: linuxArm64JRE)

// clean work folder for jpackage
def jpackageWorkdir = layout.buildDirectory.file('jpackage')
tasks.register('cleanJpkgWorkdir', Delete) {
    delete jpackageWorkdir
}

tasks.register('jars', Sync) {
    from configurations.runtimeClasspath
    from(tasks.jar) { include omegatJarFilename }
    into file(layout.buildDirectory.file('jars'))
    dependsOn tasks.jar
}

// prepare japckage contents
tasks.register('jpackageAppContentGreetings', Sync) {
    dependsOn jpackage, firstSteps

    from layout.buildDirectory.file('docs/greetings')
    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/docs/greetings")
}

tasks.register('jpackageAppContentManuals', Sync) {
    dependsOn jpackage, manualZips

    from layout.buildDirectory.file('docs/manuals')
    include '*.zip'
    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/docs/manuals")
}

tasks.register('jpackageAppContentDocs', Copy) {
    dependsOn jpackage

    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/docs")
    from("release") {
        include 'doc-license.txt'
        filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
    }
    from("release") {
        exclude 'doc-license.txt'
        include '*.txt', '*.html'
        filter(ReplaceTokens, tokens: [
                TRANSLATION_NOTICE: ''
        ])
        filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
    }
}
tasks.register('jpackageAppContentScripts', Sync) {
    from 'scripts'
    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/scripts")
    dependsOn jpackage
}
tasks.register('jpackageAppContentImages', Sync) {
    from 'images'
    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/images")
    dependsOn jpackage
}
tasks.register('jpackageAppContentModules', Sync) {
    from layout.buildDirectory.file('modules')
    into layout.buildDirectory.file("jpackage/app-image/${application.applicationName}/lib/modules")
    dependsOn subprojects.collect {it.tasks.withType(Jar)}
    dependsOn jpackage
}
tasks.register('jpackageAppContent') {
    dependsOn jpackageAppContentGreetings
    dependsOn jpackageAppContentManuals
    dependsOn jpackageAppContentDocs
    dependsOn jpackageAppContentImages
    dependsOn jpackageAppContentModules
    dependsOn jpackageAppContentScripts
}

// construct package contents in standard file tree
tasks.register('jpackage', Exec) {
    dependsOn cleanJpkgWorkdir
    dependsOn jars
    group 'other'

    inputs.files file(layout.buildDirectory.file('jars'))
    outputs.files file(layout.buildDirectory.file("jpackage/app-image"))
    onlyIf { gradleOnJava17OrLater }

    def osName = System.getProperty('os.name').toLowerCase()
    def icon = 'images/OmegaT.png'
    if (osName.contains('windows')) {
        icon = "images/OmegaT.ico"
    } else if (osName.contains('mac')) {
        icon = "images/OmegaT.icns"
    }
    commandLine(file(Paths.get(System.getProperty('java.home')).resolve("bin/jpackage")),
            '--type', 'app-image',
            '--app-version', version,
            '--description', distDescription,
            '--icon', icon,
            '--name', application.applicationName,
            '--dest', file(layout.buildDirectory.file("jpackage/app-image")),
            '--vendor', distAppVendor,
            '--input', file(layout.buildDirectory.file('jars')),
            '--main-class', application.mainClass.get(),
            '--main-jar', omegatJarFilename,
            '--java-options', "-Xmx1024M",
            '--java-options', "--add-opens",
            '--java-options', "java.desktop/sun.awt.X11=ALL-UNNAMED",
            '--resource-dir', file("release/jpackage-specific/linux/"))
}

// generate DEB package
tasks.register("linuxDebDist", Exec) {
    dependsOn jpackage
    dependsOn jpackageAppContent
    group 'distribution'
    def debVersion = '3'
    inputs.files file(layout.buildDirectory.file("jpackage/app-image/${application.applicationName}"))
    outputs.files file(layout.buildDirectory
            .file("distributions/${application.applicationName}_${version}-${debVersion}_amd64.deb"))
    onlyIf { gradleOnJava17OrLater && exePresent('dpkg-deb') }

    commandLine(file(Paths.get(System.getProperty('java.home')).resolve("bin/jpackage")),
            '--type', 'deb',
            '--app-version', version,
            '--description', distDescription,
            '--icon', file(layout.projectDirectory.file("images/OmegaT.png")),
            '--name', application.applicationName,
            '--app-image', file(layout.buildDirectory.file("jpackage/app-image/${application.applicationName}")),
            '--dest', file(layout.buildDirectory.file('distributions')),
            '--vendor', distAppVendor,
            '--resource-dir', file("release/jpackage-specific/linux/"),
            '--about-url', "https://omegat.org/",
            '--license-file', file(layout.projectDirectory.file("LICENSE")),
            '--install-dir', '/opt/omegat-org',
            '--linux-app-category', 'editors',
            '--linux-app-release', debVersion,
            '--linux-deb-maintainer', 'info@omegat.org',
            '--linux-menu-group', 'Office',
            '--linux-package-name', 'omegat',
            '--linux-shortcut')
    tasks.getByName('linux').dependsOn linuxDebDist
    assemble.dependsOn linuxDebDist
}

// generate RPM package
tasks.register("linuxRpmDist", Exec) {
    dependsOn jpackage
    dependsOn jpackageAppContent
    group 'distribution'
    def rpmVersion = '3'
    inputs.files file(layout.buildDirectory.file("jpackage/app-image/${application.applicationName}"))
    outputs.files file(layout.buildDirectory
            .file("distributions/${application.applicationName}-${version}-${rpmVersion}.x86_64.rpm"))
    onlyIf { gradleOnJava17OrLater && exePresent('rpm') }

    commandLine(file(Paths.get(System.getProperty('java.home')).resolve("bin/jpackage")),
            '--type', 'rpm',
            '--app-version', version,
            '--description', distDescription,
            '--icon', file(layout.projectDirectory.file("images/OmegaT.png")),
            '--name', application.applicationName,
            '--app-image', file(layout.buildDirectory.file("jpackage/app-image/${application.applicationName}")),
            '--dest', file(layout.buildDirectory.file('distributions')),
            '--vendor', distAppVendor,
            '--about-url', "https://omegat.org/",
            '--license-file', file(layout.projectDirectory.file("LICENSE")),
            '--install-dir', '/opt/omegat-org',
            '--linux-app-category', 'Application/Editors',
            '--linux-app-release', rpmVersion,
            '--linux-menu-group', 'Office',
            '--linux-package-name', 'omegat',
            '--linux-rpm-license-type', 'GPLv3+',
            '--linux-shortcut')
    tasks.getByName('linux').dependsOn linuxRpmDist
    assemble.dependsOn linuxRpmDist
}

// We bundle our startup scripts separately, so disable startScripts.
startScripts.enabled = false
// installDist insists on destination executable directory even when disable start script.
application.executableDir = ""

// Read in all our custom messages and massage them for inclusion in the .iss
ext.getInnoSetupCustomMessages = {
    // Don't include languages that InnoSetup doesn't have strings for
    def blacklist = ['cy', 'ia', 'mfe']
    // Sort files to ensure English comes first, to set fallback
    fileTree(dir: 'release/win32-specific', include: 'CustomMessages*.ini')
        .sort()
        .collect { file ->
            def match = file.name =~ /CustomMessages_?([^\.]*).ini/
            if (match) {
                def capture = match.group(1)
                def lang = capture.empty ? 'en' : capture
                if (!blacklist.contains(lang)) {
                    file.text.replaceAll(/(?m)^([^=]+)/) { "$lang.${it[0]}" }
                }
            }
        }.findAll()
        .join(System.lineSeparator())
}

tasks.register('win') {
    description = 'Build the Windows distributions.'
    group = 'omegat distribution'
}

ext.makeWinTask = { args ->
    def fullVersion = project.version + omtVersion.beta
    def installerBasename = "OmegaT_${fullVersion}_${args.suffix}"
    def installerWinExe = base.distsDirectory.file("${installerBasename}.exe")
    def signedWinExe = base.distsDirectory.file("${installerBasename}_Signed.exe")
    def prepDistsTaskName = "${args.name}Prep"
    def genDistsTaskName = "${args.name}Gen"
    def distsTaskName = "${args.name}"
    def signedTaskName = "${args.name}Signed"
    def signedTaskCommandArgs = { arg2 ->
        def exe = exePresent('osslsigncode') ? 'osslsigncode' : file('ci/osslsigncode').toString()
        def commandArgs = [exe, 'sign']
        if (project.hasProperty('pkcs11module')) {
            commandArgs.addAll('-pkcs11module', project.property('pkcs11module'))
        }
        if (project.hasProperty('winCodesignCert')) {
            commandArgs.addAll('-certs', project.property('winCodesignCert'))
        }
        if (project.hasProperty('pkcs11cert')) {
            commandArgs.addAll('-pkcs11cert', project.property('pkcs11cert'))
        }
        if (project.hasProperty('winCodesignPassword')) {
            commandArgs.addAll('-pass', project.property('winCodesignPassword'))
        }
        if (project.hasProperty('winCodesignDevice')) {
            envVars['USBDEV'] = project.property('winCodesignDevice')
        }
        commandArgs.addAll(
                '-t', project.hasProperty('winCodesignTimestampUrl') ? project.property('winCodesignTimestampUrl') :
                'http://time.certum.pl/',
                '-n', application.applicationName, '-i', omtWebsite, '-h', 'sha256',
                '-in', installerWinExe.get().asFile,
                '-out', signedWinExe.get().asFile
        )
        return commandArgs
    }

    tasks.register(prepDistsTaskName, Sync) {
        onlyIf {
            conditions([!args.jrePath || !args.jrePath.empty, 'JRE not found'],
                    [exePresent('iscc') || exePresent('docker') || exePresent('nerdctl'),
                     'InnoSetup or Docker not installed'])
        }
        doFirst {
            delete "$destinationDir/jre"
            delete installerWinExe
        }
        with distributions.main.contents
        destinationDir file(layout.buildDirectory.file("innosetup/${args.name}"))
        outputs.upToDateWhen {
            // detect up-to-date when OmegaT.jar exists and newer than libs/OmegaT.jar
            def f1 = layout.buildDirectory.file("innosetup/${args.name}/OmegaT.jar").get().asFile
            def f2 = base.libsDirectory.file('OmegaT.jar').get().asFile
            f1.exists() && f2.exists() && f1.lastModified() > f2.lastModified()
        }
        from('release/win32-specific') {
            include 'OmegaT.l4J.ini'
            include 'OmegaT.iss'
            filter(ReplaceTokens, tokens: [
                    VERSION_NUMBER_SUBST : fullVersion,
                    OUTPUT_BASENAME_SUBST: installerBasename.toString(),
                    CUSTOM_MESSAGES_SUBST: getInnoSetupCustomMessages(),
                    ARCHITECTURE_SUBST   : args.arch ?: ''
            ])
            filter(FixCrLfFilter, eol: FixCrLfFilter.CrLf.newInstance('crlf'))
            filteringCharset = 'UTF-8'
        }
        from('build/launch4j') {
            include '*.exe'
        }
        if (args.jrePath && !args.jrePath.empty) {
            from(zipTree(args.jrePath.singleFile)) {
                includeEmptyDirs = false
                eachFile {
                    replaceRelativePathSegment(it, /jdk.*-jre/, 'jre')
                }
            }
        }
        dependsOn createAllExecutables
    }

    tasks.register(genDistsTaskName, Exec) {
        onlyIf {
            conditions([!args.jrePath || !args.jrePath.empty, 'JRE not found'],
                    [exePresent('iscc') || exePresent('docker') || exePresent('nerdctl'),
                     'InnoSetup or Docker not installed'])
        }
        dependsOn prepDistsTaskName
        inputs.files(
                layout.buildDirectory.file("innosetup/${args.name}/OmegaT.jar"),
                layout.buildDirectory.file("innosetup/${args.name}/OmegaT.iss"),
                layout.buildDirectory.file("innosetup/${args.name}/OmegaT.l4j.ini"),
        )
        // You'd think we could just set the PATH, but there be dragons here
        // https://github.com/palantir/gradle-docker/issues/162
        def exe = exePresent('iscc') ? 'iscc' : file('ci/iscc')
        def iss = layout.buildDirectory.file("innosetup/${args.name}/OmegaT.iss").get().asFile
        logging.captureStandardOutput LogLevel.INFO
        commandLine exe, '/Qp', iss
        outputs.file layout.buildDirectory.file("innosetup/${args.name}/${installerBasename}.exe")
        doLast {
            println ""
            def f3 = layout.buildDirectory.file("innosetup/${args.name}/${installerBasename}.exe").get().asFile
            logger.info('Built ' + f3.toString() + "(" + f3.length() + ")")
        }
    }

    tasks.register(distsTaskName, Copy) {
        description = "Create a Windows installer for ${args.name} distro. " +
                'Requires Inno Setup (http://www.jrsoftware.org/isinfo.php).'
        onlyIf {
            conditions([!args.jrePath || !args.jrePath.empty, 'JRE not found'],
                    [exePresent('iscc') || exePresent('docker') || exePresent('nerdctl'),
                     'InnoSetup or Docker not installed'])
        }
        from layout.buildDirectory.file("innosetup/${args.name}/${installerBasename}.exe")
        into base.distsDirectory
        outputs.file installerWinExe
        dependsOn genDistsTaskName
    }

    tasks.register(signedTaskName, Exec) {
        group = 'omegat distribution'
        inputs.file installerWinExe skipWhenEmpty()
        outputs.file signedWinExe
        // Starting from Nov 2022, certification provider force to use HSM to
        // store private keys. Starting on June 1, 2023, at 00:00 UTC, industry
        // standards will require private keys for standard code signing
        // certificates to be stored on hardware certified as FIPS 140 Level 2,
        // Common Criteria EAL 4+, or equivalent.
        // #1179 build/release: Windows binary signature with PKCS#11 HSM
        // https://sourceforge.net/p/omegat/bugs/1179/
        // requires osslsigncode version 2.5 or later.
        onlyIf {
            // Set these in e.g. local.properties
            def props = ['pkcs11module', 'winCodesignPassword']
            conditions([props.every { project.hasProperty(it) }, 'Code signing properties not set'],
                    [exePresent('osslsigncode'), 'osslsigncode is not installed'])
                    // note: container image amake/innosetup has osslsigntool 1.7 which don't work.
                    // [exePresent('osslsigncode') || exePresent('docker') || exePresent('nerdctl'),
                    // 'neither osslsigncode or docker/nerdctl is not installed'])
        }
        doFirst {
            delete signedWinExe
        }
        def envVars = [:]
        commandLine(signedTaskCommandArgs())
        environment(envVars)
        dependsOn distsTaskName
    }
    assemble.dependsOn args.name, signedTaskName
    win.dependsOn args.name, signedTaskName
}
makeWinTask(name: 'winNoJRE', suffix: 'Windows_without_JRE')
makeWinTask(name: 'winJRE64', suffix: 'Windows_64', jrePath: windowsJRE, arch: 'x64')
makeWinTask(name: 'winJRE', suffix: 'Windows', jrePath: windowsJRE32)

// Disable .tar distributions for everyone but Linux
tasks.findAll { it.name =~ /[dD]istTar$/ && !it.name.contains('linux') }.each { it.enabled = false }
// Disable .zip distributions for Linux
tasks.findAll { it.name =~ /[dD]istZip$/ && it.name.contains('linux') }.each { it.enabled = false }

def provided = findProperty('repoRevision') ?: ''
def gitArchival = loadProperties(file('.git-archival.properties')).getProperty('node')
def git = file('.git').directory ? providers.exec {commandLine("git", "rev-parse", "--short", "HEAD")}.standardOutput.asText.get().trim() : ''
def revision = [provided, gitArchival, omtVersion.revision, git, 'unknown'].find {
    !it.empty && it != '@dev@' && it != '$Format:%H$'
}
processResources {
    /*
     Set the revision number included in version strings. The value is
     chosen from the first valid value in:
     0. Provided as the Gradle property 'repo.revision'
     1. src/org/omegat/Version.properties (only if not "dev", i.e. this is a
        source package not under VCS)
     2. This git clone's SHA-1
     3. If none of the above, the value "unknown"
     */
    inputs.property 'revision', revision
    logger.lifecycle("Detected revision " + revision)
    filesMatching('**/Version.properties') {
        filter ReplaceTokens, tokens:["dev": revision]
    }
}

tasks.register('checksums') {
    def algos = ['SHA-512']
    description = "Generate ${algos.join(', ')} checksums for distribution files"
    inputs.files fileTree(dir: base.distsDirectory, exclude: 'checksums')
    outputs.dir base.distsDirectory.dir('checksums')
    onlyIf {
        condition(base.distsDirectory.get().asFile.directory, 'Distfiles not found')
    }
    doLast {
        base.distsDirectory.get().asFile.listFiles().findAll { it.file }.each { f ->
            algos.each { algo ->
                ant.checksum file: f, algorithm: algo, todir: distsDirectory.dir('checksums').get().asFile
            }
        }
    }
}

tasks.register('genJAXB') {
    description = 'Generate classes for loading and manipulating XML formats'
}

ext.makeJaxbTask = { args ->
    def taskName = "gen${args.name.capitalize()}"
    tasks.register(taskName, JavaExec) {
        classpath = configurations.jaxb
        mainClass = 'com.sun.tools.xjc.XJCFacade'
        delegate.args args.args
        outputs.dir args.outdir
    }
    genJAXB.dependsOn taskName
}

makeJaxbTask(name: 'segmentation', outdir: 'src/gen/core/segmentation',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.segmentation', 'src/schemas/srx20.xsd'])
makeJaxbTask(name: 'filters', outdir: 'src/gen/core/filters',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.filters', 'src/schemas/filters.xsd'])
makeJaxbTask(name: 'tbx', outdir: 'src/gen/core/tbx',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.tbx', 'src/schemas/tbx.xsd'])
makeJaxbTask(name: 'project', outdir: 'src/gen/core/project',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.project', 'src/schemas/project_properties.xsd'])
makeJaxbTask(name: 'tmx14', outdir: 'src/gen/core/tmx14',
             args: ['-no-header', '-d', 'src', '-p', 'gen.core.tmx14', '-b', 'src/schemas/tmx14.xjb', 'src/schemas/tmx14.xsd'])

tasks.register('changedOnBranch') {
    description = 'List files that have been modified on this git branch.'
    doLast {
        ext.files = project.files(gitModifiedFiles())
        ext.files.each { println(it) }
    }
}

tasks.register('spotlessChangedApply') {
    description = 'Apply code formatting to files that have been changed on the current branch.'
    group = 'omegat workflow'
    finalizedBy 'spotlessApply'
    dependsOn changedOnBranch
    doFirst {
        spotlessJava.target = changedOnBranch.files.findAll {
            it.path.endsWith('.java')
        }
    }
}

jacoco {
    toolVersion = "0.8.12"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test) // tests are required to run before generating the report
    group = 'verification'
    reports {
        xml.required = true  // coveralls plugin depends on xml format report
        html.required = true
    }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: ["gen/core/**/*", "org/omegat/util/gui/*", "org/omegat/gui/dialogs/*",
                              "org/omegat/externalfinder/gui/*", "org/omegat/gui/filters2/*", "org/omegat/core/team2/gui/*",
                              "org/omegat/gui/properties", "org/omegat/gui/exttrans/*", "org/omegat/gui/theme",
                              "org/omegat/gui/comments/*", "org/omegat/gui/editor/chartable/*",
                              "org/omegat/gui/segmentation/*", "org/omegat/util/xml/*", "org/omegat/gui/preferences/*",
                              "org/omegat/**/data/*", "org/omegat/**/datamodels/*"])
        }))
    }
}

// check.dependsOn jacocoTestCoverageVerification
tasks.jacocoTestCoverageVerification {
    dependsOn(tasks.test)
    violationRules {
        rule {
            element = 'CLASS'
            includes = ['org.omegat.core.machinetranslators.*', 'org.omegat.core.dictionaries.*']
            excludes = ['**.*.1', '**.*.2', '**.*.3',  // ignore inner classes
                    'org.omegat.core.machinetranslators.MachineTranslators']  // simple plugin reg.
            limit { minimum = 0.20 }
        }
        rule {
            element = 'PACKAGE'
            includes = ['org.omegat.filters?.*',
                        'org.omegat.externalfinder', 'org.omegat.languagetools', 'org.omegat.util',
                        'org.omegat.core.events', 'org.omegat.core.matching', 'org.omegat.core.search',
                        'org.omegat.core.segmentation', 'org.omegat.core.spellchecker', 'org.omegat.core.statistics',
                        'org.omegat.core.tagvalidation', 'org.omegat.core.team2.*']
            excludes = ['org.omegat.core.team2.gui', 'org.omegat.util.xml.*']
            limit { minimum = 0.60 }
        }
    }
}

tasks.getByName("run") {
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED"])
}

tasks.register('debug', JavaExec) {
    description = 'Launch app for debugging.' // Special debug task for NetBeans
    group = 'application'
    mainClass = application.mainClass
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs(["--illegal-access=warn"])
    debug true
}

tasks.register('runOnJava17', JavaExec) {
    description = 'Launch app on Java 17'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    mainClass.set application.mainClass
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED"])
    group = 'application'
}

tasks.register('runOnJava21', JavaExec) {
    description = 'Launch app on Java 21'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(21)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    mainClass.set application.mainClass
    classpath = sourceSets.main.runtimeClasspath
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED"])
    group = 'application'
}

// E.g. when doing `build`, run checks before making distfiles
assemble.mustRunAfter check

test {
    // Test in headless mode with ./gradlew test -Pheadless
    if (project.hasProperty('headless')) {
        systemProperty 'java.awt.headless', 'true'
    }
}

tasks.register('testIntegration', JavaExec) {
    description = 'Run integration tests. Pass repo URL as -Domegat.test.repo=<repo>'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    group = 'omegat workflow'
    mainClass = 'org.omegat.core.data.TestTeamIntegration'
    classpath = sourceSets.testIntegration.runtimeClasspath
    systemProperties = System.properties
}

tasks.register('testOnJava17', Test) {
    description = 'Run test cases on Java 17'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    if (project.hasProperty('headless')) {
        systemProperty 'java.awt.headless', 'true'
    }
    group = 'verification'
}

tasks.register('testOnJava21', Test) {
    description = 'Run test cases on Java 21'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(21)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    if (project.hasProperty('headless')) {
        systemProperty 'java.awt.headless', 'true'
    }
    group = 'verification'
}

tasks.register('testAcceptance', Test) {
    description = 'Run Acceptance GUI test'
    group = 'verification'
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ADOPTIUM
    }
    jvmArgs(["--add-opens", "java.desktop/sun.awt.X11=ALL-UNNAMED",
             "--add-opens", "java.base/java.util=ALL-UNNAMED"])
    testClassesDirs = sourceSets.testAcceptance.output.classesDirs
    classpath = sourceSets.testAcceptance.runtimeClasspath
    systemProperties = System.properties
    shouldRunAfter(tasks.test)
}

ext.mavenStyleVersion = version.replace('_', '-')

publishing {
    publications {
        mavenJava(MavenPublication) { publication ->
            groupId = 'org.omegat'
            artifactId = 'omegat'
            version = mavenStyleVersion
            from components.java

            pom {
                name = 'OmegaT'
                description = distDescription
                url = 'https://omegat.org'
                scm {
                    connection = "scm:git:https://git.code.sf.net/p/omegat/code"
                    developerConnection = "scm:git:https://git.code.sf.net/p/omegat/code"
                    url = "https://sourceforge.net/p/omegat/code/"
                }
                licenses {
                    license {
                        name = 'The GNU General Public License, Version 3.0'
                        url = 'https://www.gnu.org/licenses/licenses/gpl-3.0.html'
                    }
                }
                developers {
                    developer {
                        id = 'omegat'
                        name = 'OmegaT Developers'
                        email = 'info@omegat.org'
                    }
                }
            }
        }
    }
    repositories {
        maven {
            url = 'https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/'
            credentials(PasswordCredentials) {
                username findProperty('ossrhUsername')
                password findProperty('ossrhPassword')
            }
        }
    }
}

signing {
    sign publishing.publications.mavenJava
    if (!findProperty("signing.keyId")) {
        useGpgCmd()
    }
}

remotes {
    sourceforgeWeb {
        host = 'web.sourceforge.net'
        user = findProperty('sourceforgeWebUser')
        password = findProperty('sourceforgeWebPassword')
        agent = true
    }
}

ext.htdocs = '/home/project-web/omegat/htdocs'

ext.publishAtomically = { args ->
    task("publish${args.name.capitalize()}") {
        description = "Copy ${args.name} to SourceForge web."
        dependsOn args.sourceTask
        group = 'omegat release'
        doLast {
            ssh.run {
                session(remotes.sourceforgeWeb) {
                    def timestamp = new Date().format('yyyyMMddHHmmss')
                    def targetDir = args.targetDir ?: "${args.name}-${omtFlavor}"
                    def tempDir = "${targetDir}-temp-${timestamp}"
                    sftp {
                        cd htdocs
                        mkdir tempDir
                    }
                    put from: args.sourceTask.outputs.files, into: "${htdocs}/${tempDir}"
                    sftp {
                        cd htdocs
                        try { rename targetDir, "${targetDir}-old-${timestamp}" }
                        catch (ignored) {}
                        rename "${tempDir}/${args.sourceTask.destinationDir.name}", targetDir
                        rmdir tempDir
                    }
                }
            }
        }
    }
}

publishAtomically(name: 'manual', sourceTask: webManual)
publishAtomically(name: 'javadoc', sourceTask: javadoc)

tasks.register('publishVersion') {
    description = 'Update the version considered current by the version check.'
    group = 'omegat release'
    doLast {
        ssh.run {
            session(remotes.sourceforgeWeb) {
                def target = "${htdocs}/Version-${omtFlavor}.properties"
                put from: file('src/org/omegat/Version.properties'), into: target
            }
        }
    }
}

tasks.withType(JavaExec).configureEach {
    // Allow setting the max heap size for the run task from the command line, e.g.
    // `gradle -PrunMaxHeapSize=1024M run`
    maxHeapSize = findProperty('runMaxHeapSize')
    // Ask modules to be up-to-date before run task executed
    dependsOn subprojects.tasks.jar
    dependsOn firstSteps
}

tasks.register('printVersion') {
    println project.version
}

tasks.withType(Copy).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
tasks.withType(Sync).configureEach {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}
tasks.withType(Zip).configureEach {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}
