<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   <title>Source Segmentation - OmegaT 1.6.1 User Manual</title>
</head>
<body>

<h1>Source Segmentation</h1>

<h2>Contents</h2></div>

<ul type="none">
   <li>1. <a href="#Segmentation_Basics">Segmentation Basics</a></li>

   <li>
      2. <a href="#Sentence_Segmentation">Sentence Segmentation</a>

      <ul>
         <li>2.1. <a href="#About_Rules">About Rules</a></li>

         <li>
            2.2. <a href="#Rules_Setup">Rules Setup</a>

            <ul>
               <li>2.2.1. <a href="#Sets_of_Rules">Sets of Rules</a></li>
               <li>2.2.2. <a href="#Simple_examples">Simple examples</a></li>
            </ul>
         </li>

         <li>
            2.3. <a href="#Regular_Expressions_to_use_in_segmentation_rules">
            Regular Expressions to use in segmentation rules</a>

            <ul>
               <li>2.3.1. <a href="#Short_summary_of_regular-expression_constructs">
               Short summary of regular-expression constructs</a></li>
            </ul>
         </li>
      </ul>
   </li>
</ul>

<a name="Segmentation_Basics"></a>
<h2>Segmentation Basics</h2>

<p>
Translation memory tools work with textual units called segments.
There are multiple ways to segment a text.
</p>

<p>
OmegaT first parses the text for structure-level segmentation. During this 
process it is only the structure of the source file that is used to produce 
segments. For example, text files may be segmented on line breaks, empty lines,
or not be segmented on a structure level at all. Files with formatting
(OpenOffice.org, OpenDocument, XHTML and HTML documents) are segmented
on block-level (paragraph) tags.
</p>

<p>
Translatable object attributes (in XHTML or HTML files) are also extracted to
separate segments.
</p>

<p>
OmegaT may also segment by sentence. Sentence segmentation takes place after 
structure-level segmentation. Segments created during either process 
unfortunately cannot be changed (split or merged) during translation. This
is a limitation of OmegaT we do recognize.
</p>

<p>
If you are not satified with the segmentation you will need to either modify 
the source file externally and/or to modify the sentence segmentation rules. 
Once this is done you will need to reload the project for your modifications 
to be taken into account.
</p>

<a name="Sentence_Segmentation"></a>
<h2>Sentence Segmentation</h2>

<p>
After OmegaT has segmented the source file into logical units, for formatted 
files usually corresponding to paragraphs, it will further segment these 
blocks into sentences if you don't turn the Sentence Segmenting off. 
Generally speaking, OmegaT may segment the logical source file blocks into 
any segments you setup it to. However as <strong>by default</strong> OmegaT 
segments into sentences, we will call it <strong>sentence</strong> segmentation.
</p>

<p>
The Sentence Segmentation was built with the
<a href="http://www.lisa.org/standards/srx/">Segmentation Rules eXchange (SRX)</a>
standard in mind, though as of current writing, OmegaT neither supports all SRX
features, nor is able to import/export rules defined in SRX format. Yet if you
know how SRX works, you already know how OmegaT works, as they are more or less
the same.
</p>

<a name="About_Rules"></a>
<h3>About Rules</h3>

<p>
There are two kinds of possible rules.
</p>

<ul>
   <li>Break rules break the text into segments.</li>
   <li>Exception rules specify what chunks of text should not be separated from others.</li>
</ul>

<p>
Break rule example: <i>"Did it make sense? I was not sure."</i>
can be segmented as two sentences after the "<code>?</code>".
There should be a break rule for "<code>?</code>".
</p>

<p>
Exception rule example: <i>"Who is afraid of Mrs. Woolf?"</i> cannot
be segmented after the "<code>.</code>". There should be an exception
rule for "<code>Mrs.</code>".
</p>

<p>
The predefined break rules should be sufficient for most European languages 
and Japanese, but we recommend to define more exception rules for the language 
you translate from, as it is obviosly impossible to predefine all possible 
exceptions for all possible languages.
</p>

<a name="Rules_Setup"></a>
<h3>Rules Setup</h3>

<p>
In order to setup the rules, select <strong>Options -&gt; Segmentation...</strong>
from the main menu. Note that if you change segmentation options when any
project is open, you will have to reload the project for the changes to take
effect.
</p>

<a name="Sets_of_Rules"></a>
<h4>Sets of Rules</h4>

<p>
All the segmentation rule sets with a matching Language Pattern are applied
in the given order of priority, so rules for specific language should be higher
than default ones.
</p>

<p>
For example, rules for Canadian French (FR-CA) should be higher than rules
for French (FR.*), and higher than Default (.*) ones. Then while translating
from Canadian French your project will use the rules defined for this language,
the rules for French, and the Default rules in a correct order.
</p>

<p>
In order to create an empty set of rules, click <strong>Add</strong> in the
upper half of the dialog. An empty line appears at the bottom of a table.
Change the name of the rule set and the language pattern. Syntax of the
language pattern conforms to regular expression syntax.
See the section <a href="#Short_summary_of_regular-expression_constructs">
Short summary of regular-expression constructs</a> below.
</p>

<p>
If your set of rules handles a language-country pair, we advise you to move it
to the top using <strong>Move Up</strong> button.
</p>

<p>
In order to edit a set of rules, simply click on it in a table, the rules of
the set will appear in the bottom half of the window.
</p>

<p>
The Break/Exception checkbox determines whether it is a break rule
(checkbox set) or an exception rule (checkbox unset). Two regular expressions
Before and After specify what must be before and after some position so that
it qualifies for exception rule or for break rule.
</p>

<p>
The process of segmenting may be simplified to the following. Imagine a cursor
moving from after the first to before the last symbol of the text. For each
cursor position we take each rule in the given order and try to apply the
<strong>Before</strong> pattern to all the text that is on the left of a cursor 
and the <strong>After</strong> pattern to the text on the right so that they 
touch the cursor.
</p>

<p>
If the application of some rule is successful, for exception rules we do
nothing but stop examining more rules, and for break rules we take the text
on the left as a separate segment, for each cursor position in the text.
</p>

<a name="Simple_examples"></a>
<h4>Simple examples</h4>

<p>
<dl>
   <dt><strong>Aim:</strong> to set a segment after a period ('<code>.</code>') and before a space</dt>
   <dd>
      Before: <code>\.</code> After: <code>\s</code>
      <br />
      <strong>Note:</strong> "<code>\.</code>" means the character "<code>.</code>"
      <br />
      "<code>\s</code>" means any white space character
   </dd>

   <dt><strong>Aim:</strong> to not set a segment after "<code>Mr.<c/code>"</dt>
   <dd>
      Before: <code>Mr\.</code> After: <code>\s</code>
      <br />
      <strong>Note:</strong> Don't forget to leave the rule box <strong>unchecked</strong>
   </dd>

   <dt><strong>Aim:</strong> to set a segment after "。" (Japanese period)</dt>
   <dd>
      Before: 。 After: (empty)
      <br />
      <strong>Note:</strong> You can leave a field empty
   </dd>
</dl>
</p>

<a name="Regular_Expressions_to_use_in_segmentation_rules"></a>
<h3>Regular Expressions to use in segmentation rules</h3>

<p>
The segmentation rules themselves are represented using regular expressions.
This allows for maximum flexibility in the definition of the rules and
conforms to SRX.
</p>

<a name="Short_summary_of_regular-expression_constructs"></a>
<h4>Short summary of regular-expression constructs</h4>

<p>
These are not the only constructs you may use in OmegaT segmentation rules, 
but rather the most commonly used. OmegaT supports all the regular expression 
features as described in <a href="http://www.lisa.org/standards/srx/">SRX standard</a>.
</p>

<table border="0" width="80%" cellpadding="1" cellspacing="0" summary="Regular expression constructs, and what they match">
    <tr bgcolor="#DDEEFF"><th width="10%" align="left" id="construct">Construct&nbsp;</th><th align="left">Matches</th></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="flags">Flags</th></tr>
    <tr><td><tt>(?i)</tt></td><td>Enables case-insensitive matching (by default, the pattern is case-sensitive).</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr><th align="left" colspan="2" id="characters">Characters</th></tr>
    <tr><td><strong>x</strong></td><td>The character <strong>x</strong>, except the following...</td></tr>

    <tr><td><tt>\u</tt><strong>hhhh</strong></td><td>The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><strong>hhhh</strong></td></tr>
    <tr><td><tt>\t</tt></td><td>The tab character (<tt>'\u0009'</tt>)</td></tr>
    <tr><td><tt>\n</tt></td><td>The newline (line feed) character (<tt>'\u000A'</tt>)</td></tr>

    <tr><td><tt>\r</tt></td><td>The carriage-return character (<tt>'\u000D'</tt>)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="quot">Quotation</th></tr>
    <tr><td><tt>\</tt></td><td>Nothing, but quotes the following character. This is required if you would like to enter of the metacharacters <code>!$()*+.&lt;&gt;?[\]^{|}</code> to match as themselves.</td></tr>

    <tr><td><tt>\\</tt></td><td>For example, this is the backslash character</td></tr>
    <tr><td><tt>\Q</tt></td><td>Nothing, but quotes all characters until <tt>\E</tt></td></tr>
    <tr><td><tt>\E</tt></td><td>Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>

    <tr><td><tt>[abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
    <tr><td><tt>[^abc]</tt></td><td>Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>

    <tr><td><tt>[a-zA-Z]</tt></td><td><tt>a</tt> through <tt>z</tt> or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>

    <tr><td><tt>.</tt></td><td>Any character (except for line terminators)</td></tr>
    <tr><td><tt>\d</tt></td><td>A digit: <tt>[0-9]</tt></td></tr>
    <tr><td><tt>\D</tt></td><td>A non-digit: <tt>[^0-9]</tt></td></tr>
    <tr><td><tt>\s</tt></td><td>A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>

    <tr><td><tt>\S</tt></td><td>A non-whitespace character: <tt>[^\s]</tt></td></tr>
    <tr><td><tt>\w</tt></td><td>A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
    <tr><td><tt>\W</tt></td><td>A non-word character: <tt>[^\w]</tt></td></tr>
    <tr><th>&nbsp;</th></tr>

    <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
    <tr><td><tt>^</tt></td><td>The beginning of a line</td></tr>
    <tr><td><tt>$</tt></td><td>The end of a line</td></tr>
    <tr><td><tt>\b</tt></td><td>A word boundary</td></tr>
    <tr><td><tt>\B</tt></td><td>A non-word boundary</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
    <tr><td colspan="2">These will match as much as they can. For example, <code>a+</code> will match <code>aaa</code> in <code>aaabbb</code></td></tr>
    <tr><td><strong>X</strong><tt>?</tt></td><td><strong>X</strong>, once or not at all</td></tr>

    <tr><td><strong>X</strong><tt>*</tt></td><td><strong>X</strong>, zero or more times</td></tr>
    <tr><td><strong>X</strong><tt>+</tt></td><td><strong>X</strong>, one or more times</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="reluc">Reluctant (non-greedy) quantifiers</th></tr>

    <tr><td colspan="2">These will match as little as they can. For example, <code>a+?</code> will match the first <code>a</code> in <code>aaabbb</code></td></tr>
    <tr><td><strong>X</strong><tt>??</tt></td><td><strong>X</strong>, once or not at all</td></tr>
    <tr><td><strong>X</strong><tt>*?</tt></td><td><strong>X</strong>, zero or more times</td></tr>

    <tr><td><strong>X</strong><tt>+?</tt></td><td><strong>X</strong>, one or more times</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>
    <tr><td><strong>XY</strong></td><td><strong>X</strong> followed by <strong>Y</strong></td></tr>

    <tr><td><strong>X</strong><tt>|</tt><strong>Y</strong></td><td>Either <strong>X</strong> or <strong>Y</strong></td></tr>
    <tr><td><tt>(</tt><strong>XY</strong><tt>)</tt></td><td><strong>XY</strong> as a single group</td></tr>

</table>

<hr>
<p><a href="legalNotices.html" title="Legal Notices">Legal Notices</a></p>

</body>
</html>