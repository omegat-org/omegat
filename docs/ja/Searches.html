<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=UTF-8">
   <title>検索 - OmegaT 1.6.2 取扱説明ガイド</title>
</head>
<body>

<h1>検索</h1>

<h2>目次</h2>

<ul type="none">
   <li>1. <a href="#Search_window">検索ウィンドウ</a></li>
   <li>2. <a href="#Search_locations">検索位置</a></li>

   <li>3. <a href="#Search_methods">検索方法</a>

      <ul type="none">
         <li>3.1. <a href="#Exact searches">完全一致検索</a></li>
         <li>3.2. <a href="#Keyword_searches">キーワード検索</a></li>
      </ul>
   </li>

   <li>4. <a href="#Searching_using_wildcards">ワイルドカードを使った検索</a></li>

   <li>5. <a href="#Searching_using_regular_expressions">正規表現を使った検索</a>

      <ul>
         <li>5.1. <a href="#Regular_Expressions_to_use_in_searches">検索で使う正規表現</a></li>
         <li>5.2. <a href="#Short_summary_of_regular-expression_constructs"> 正規表現構造の短い要約</a></li>
      </ul>
   </li>
</ul>

<a name="Search_window"></a>
<h2>検索ウィンドウ</h2>

<p>OmegaT は強力な検索機能を提供します。</p>

<p><code>Ctrl+F</code>を押して検索ウィンドウを呼び出し、「検索文字列」テキストボックスに検索したい単語やフレーズを入力して下さい。</p>

<p>あるいは、編集フィールド(注目している分節の訳文)の単語又はフレーズを選択して、<code>Ctrl+F</code>を押して下さい。この場合、「検索文字列」テキストボックスに単語又はフレーズが自動的に入力されます。</p>

<p>検索ウィンドウの呼び出し時はいつも新しいウィンドウを作成します。これらを閉じるのを忘れたときは、検索ウィンドウが複数開くことになります。</p>

<p>検索は、原文、訳文の両方に対して行なわれます。</p>

<a name="Search_locations"></a>
<h2>検索位置</h2>

<p>チェックボックスを使って位置を選択します。</p>

<p>検索する場所を選択できます:</p>

<ul>
   <li>このプロジェクトのみ(デフォルトの設定)</li>
   <li>プロジェクトに加えて/tm/にある翻訳メモリも検索する(<i>参考翻訳メモリ検索</i>にチェック)</li>
   <li>単一のファイルまたは、複数のファイルを含むフォルダ(<i>ファイル検索</i>にチェック)</li>
</ul>

<p>後者の場合、OmegaT は読み込み可能なファイルだけを検索します(<a href="fileFormats">対応するファイル形式</a>を参照してください)。</p>

<a name="Search_methods"></a>
<h2>検索方法</h2>

<p>ラジオボタンを使って方法を選択します。</p>

<p>二つの検索方法から選ぶことができます:</p>

<ul>
   <li><strong>完全一致検索</strong>: 指定した文字列を含む分節を検索します。</li>
   <li><strong>キーワード検索</strong>: 指定した全てのキーワードを任意の順序で含む分節を検索します。</li>
</ul>

<p>二つの方法のどちらかを選ぶと、以下の三つのオプションを選ぶことができます:</p>

<ul>
   <li>
      <strong>大文字と小文字を区別します</strong>: 選択すると、指定された文字列と正確に同じものを検索します; そうでなければ大文字と小文字の違いは無視します。</li>

   <li>
      <strong>正規表現</strong>: 選択すると、検索文字列を正規表現として扱います(キーワード検索の場合は複数の表現として扱います)。</li>

   <li>
      <strong>参考翻訳メモリ検索</strong>: 選択すると、全ての翻訳メモリも検索されます。</li>
</ul>

<a name="Exact_searches"></a>
<h2>完全一致検索</h2>

<p>完全一致検索はフレーズを検索します; 複数の単語が入力された場合は、それらが完全に同じ順番で出てくる場合のみを検索します。完全一致検索は Google のようなインターネット検索エンジンの「フレーズを含む」検索と似ています。</p>

<a name="Keyword_searches"></a>
<h2>キーワード検索</h2>

<p>「キーワード検索」を選択して、任意の数の単語をスペースで区切って任意の順番で入力すると、OmegaT は全ての単語が存在する全ての分節のリストを表示します。キーワード検索は Google のようなインターネット検索エンジンでの「全てのキーワードを含む」と同じようなものです(AND ロジック)。</p>

<a name="Searching_using_wildcards"></a>
<h2>ワイルドカードを使った検索</h2>

<p>完全一致検索とキーワード検索の両方で、ワイルドカード検索文字 '<code>*</code>' と '<code>?</code>' が使えます。ワイルドカードを使うには、<strong>正規表現</strong>が選択されていないことを確認してください;さもないと正規表現の特別な文字として扱われます。</p>

<p>ワイルドカード文字'<code>?</code>'は一つの文字にマッチングします;例えば、'<code>b?d</code>'は'<code>bad</code>' と '<code>bid</code>' にマッチングします。ワイルドカード文字 '<code>*</code>' は任意の数の文字とマッチングします; 例えば、 '<code>b*d</code>' は '<code>bad</code>', '<code>bid</code>', '<code>bold</code>' , '<code>band</code>' にマッチングします。</p>

<p>このような文字を含む分節を検索したい場合、正規表現を有効にして、それらの文字を逆スラッシュ('<code>\</code>')を使ってエスケープする必要があります;例えば'<code>x*y</code>' を検索したいときは'<code>x\*y</code>', <code>x?y</code> を検索したいときは '<code>x\?y</code>' とします。</p>

<a name="Searching_using_regular_expressions"></a>
<h2>正規表現を使った検索</h2>

<p>正規表現検索は文字列を検索するための強力な方法です。これは通常の検索に似ていますが、遥かに柔軟性があります。web 上で単純なチュートリアルを見つけることができます(例えば: <a href="http://www.regular-expressions.info/quickstart.html" title="http://www.regular-expressions.info/quickstart.html" rel="nofollow">http://www.regular-expressions.info/quickstart.html</a>)。</p>

<a name="Regular_Expressions_to_use_in_searches"></a>
<h3>検索で使う正規表現</h3>

<p>検索で使える正規表現は Java で対応しているものです。より詳細な情報が必要な場合は、<a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html"> http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html</a>を参照してください。</p>

<a name="Short_summary_of_regular-expression_constructs"></a>
<h4>正規表現構造の短い要約</h4>

<table border="0" width="80%" cellpadding="1" cellspacing="0" summary="正規表現構造と、それらが何にマッチするか">
    <tr bgcolor="#DDEEFF"><th width="10%" align="left" id="construct">構造</th><th align="left">マッチ</th></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="flags">フラグ</th></tr>
    <tr><td><tt>(?i)</tt></td><td>マッチングの時に大文字小文字を区別しません (デフォルトでは、大文字小文字を区別します)。</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr><th align="left" colspan="2" id="characters">文字</th></tr>

    <tr><td><strong>x</strong></td><td>文字<strong>x</strong>そのものですが、以下のものは例外です...</td></tr>
    <tr><td><tt>\u</tt><strong>hhhh</strong></td><td>16 進数 <tt>0x</tt><strong>hhhh</strong>の値を持つ文字</td></tr>
    <tr><td><tt>\t</tt></td><td>タブ文字(<tt>'\u0009'</tt>)</td></tr>

    <tr><td><tt>\n</tt></td><td>改行文字(<tt>'\u000A'</tt>)</td></tr>
    <tr><td><tt>\r</tt></td><td>復帰文字(<tt>'\u000D'</tt>)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="quot">クォート</th></tr>

    <tr><td><tt>\</tt></td><td>どの文字も表しませんが、次の文字をクォートします。これはメタキャラクタ<code>!$()*+.&lt;&gt;?[\]^{|}</code>を、その文字そのものとマッチングさせたいときに必要です。</td></tr>
    <tr><td><tt>\\</tt></td><td>例えば、これはバックスラッシュ文字です。</td></tr>
    <tr><td><tt>\Q</tt></td><td>どの文字も表しませんが、<tt>\E</tt>までの全ての文字をクォートします。</td></tr>

    <tr><td><tt>\E</tt></td><td>どの文字も表しませんが、<tt>\Q</tt>から続くクォートを終了させます。</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="classes">文字クラス</th></tr>
    <tr><td><tt>[abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, <tt>c</tt>のいずれか (単純クラス)</td></tr>

    <tr><td><tt>[^abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, <tt>c</tt>以外の文字 (否定)</td></tr>
    <tr><td><tt>[a-zA-Z]</tt></td><td><tt>a</tt> から <tt>z</tt> または <tt>A</tt> から <tt>Z</tt>  (範囲)</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="predef">定義済みの文字クラス</th></tr>
    <tr><td><tt>.</tt></td><td>(行末文字を除く)任意の文字</td></tr>
    <tr><td><tt>\d</tt></td><td>数値: <tt>[0-9]</tt></td></tr>
    <tr><td><tt>\D</tt></td><td>数字: <tt>[0-9]</tt></td></tr>

    <tr><td><tt>\s</tt></td><td>空白文字: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
    <tr><td><tt>\S</tt></td><td>非空白文字: <tt>[^\s]</tt></td></tr>
    <tr><td><tt>\w</tt></td><td>単語文字: <tt>[a-zA-Z_0-9]</tt></td></tr>
    <tr><td><tt>\W</tt></td><td>非単語文字: <tt>[^\w]</tt></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="bounds">境界とマッチングするもの</th></tr>
    <tr><td><tt>^</tt></td><td>行頭</td></tr>
    <tr><td><tt>$</tt></td><td>行末</td></tr>
    <tr><td><tt>\b</tt></td><td>単語の区切り</td></tr>

    <tr><td><tt>\B</tt></td><td>単語の区切りでないもの</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="greedy">貪欲量指定子</th></tr>
    <tr><td colspan="2">これらはできるだけたくさんの文字とマッチングします。例えば、<code>a+</code> は <code>aaabbb</code> の中の <code>aaa</code> とマッチングします。</td></tr>

    <tr><td><strong>X</strong><tt>?</tt></td><td>0個か1個の<strong>X</strong></td></tr>
    <tr><td><strong>X</strong><tt>*</tt></td><td>0個以上の<strong>X</strong></td></tr>
    <tr><td><strong>X</strong><tt>+</tt></td><td>1個以上の<strong>X</strong></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="reluc">無欲量指定子</th></tr>
    <tr><td colspan="2">これらはできるだけ少しの文字とマッチングします。例えば、<code>a+?</code> は<code>aaabbb</code>の中の最初の<code>a</code>とマッチングします。</td></tr>
    <tr><td><strong>X</strong><tt>??</tt></td><td>0個か1個の<strong>X</strong></td></tr>

    <tr><td><strong>X</strong><tt>*?</tt></td><td>0個以上の<strong>X</strong></td></tr>
    <tr><td><strong>X</strong><tt>+?</tt></td><td>1個以上の<strong>X</strong></td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="logical">論理演算子</th></tr>

    <tr><td><strong>XY</strong></td><td><strong>X</strong>に引き続いて<strong>Y</strong></td></tr>
    <tr><td><strong>X</strong><tt>|</tt><strong>Y</strong></td><td><strong>X</strong>か<strong>Y</strong>のどちらか</td></tr>

    <tr><td><tt>(</tt><strong>XY</strong><tt>)</tt></td><td><strong>XY</strong>を一つのグループとする</td></tr>
</table>

<hr>
<p><a href="legalNotices.html" title="特記事項">特記事項</a></p>

</body>
</html>