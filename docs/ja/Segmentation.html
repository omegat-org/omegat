<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=UTF-8">
   <title>翻訳対象ファイルの分節化 - OmegaT 1.6.2 User Manual</title>
</head>
<body>

<h1>翻訳対象ファイルの分節化</h1>

<h2>目次</h2></div>

<ul type="none">
   <li>1. <a href="#Segmentation_Basics">分節化の基本</a></li>

   <li>2. <a href="#Sentence_Segmentation">文単位の分節化</a>

      <ul>
         <li>2.1. <a href="#About_Rules">規則について</a></li>

         <li>2.2. <a href="#Rules_Setup">規則の設定</a>

            <ul>
               <li>2.2.1. <a href="#Sets_of_Rules">規則セット</a></li>
               <li>2.2.2. <a href="#Simple_examples">簡単な例</a></li>
            </ul>
         </li>

         <li>2.3. <a href="#Regular_Expressions_to_use_in_segmentation_rules"> 分節化規則で使う正規表現</a>

            <ul>
               <li>2.3.1. <a href="#Short_summary_of_regular-expression_constructs"> 正規表現構造の短い要約</a></li>
            </ul>
         </li>
      </ul>
   </li>
</ul>

<a name="Segmentation_Basics"></a>
<h2>分節化の基本</h2>

<p>翻訳メモリツールは分節と呼ばれる文書単位で作業を行ないます。文書を文節化する方法は複数あります。</p>

<p>OmegaT は最初に文書を構造レベルの分節化のためにパースします。この処理中はソースファイルの構造だけが分節の生成に使われます。 例えば、テキストファイルは改行や空行で分節化されるかもしれませんし、構造レベルでは全く分節化されないかもしれません。フォーマットのあるファイル(OpenOffice.org, OpenDocument, XHTML,  HTML ドキュメント)はブロックレベル(段落)タグで分節化されます。</p>

<p>(XHTML または HTML ファイルの)翻訳可能なオブジェクト属性も別々の分節に展開されます。</p>

<p>OmegaT は文単位で分節化することもできます。文単位の分節化は構造レベルの分節化の後に行なわれます。両方の処理中に作成された分節は残念ながら翻訳中には変更(分割又は結合)できません。これは我々が認識している OmegaT の制限です。</p>

<p>もしこの分節化に満足できない場合、ソースファイルを外部的に修正するか、文単位の分節化規則を修正する必要があります。これを行なった場合、変更を適用するためにプロジェクトを再読み込みする必要があります。</p>

<a name="Sentence_Segmentation"></a>
<h2>文単位の分節化</h2>

<p>OmegaTがソースファイルを論理単位(これはフォーマット化されたファイルでは通常段落です)に分節化した後、文単位の分節化機能をオフにしていなければ、これらのブロックをさらに文単位に分節化します。一般的に言って、 OmegaT は設定次第でソースファイルの論理ブロックをどのような形にでも分節化できます。しかし、<strong>デフォルトでは</strong> OmegaT は文単位で分節化するので、我々はこれを<strong>文単位の</strong>分節化と呼んでいます。</p>

<p>文単位の分節化は <a href="http://www.lisa.org/standards/srx/">Segmentation Rules eXchange (SRX)</a> 標準を考慮に入れて構築されていますが、この文書を記述している時点では、OmegaT はSRX の全ての機能に対応していませんし、SRX フォーマットでのルールのインポート・エクスポートにも対応していません。もし SRX がどのように働くかを知っているなら、すでに OmegaT がどのように働くかを知っていることになります。この二つはほぼ同じものだからです。</p>

<a name="About_Rules"></a>
<h3>規則について</h3>

<p>二種類の規則があります。</p>

<ul>
   <li>分割規則は文書を分節に分割します。</li>
   <li>例外規則はどのような文書のかたまりは分割するべきではないかを指定します。</li>
</ul>

<p>分割規則の例: <i>"Did it make sense?I was not sure."</i> これは "<code>?</code>" の後ろで二つの文に分節化されます。"<code>?</code>"のための分割規則があるべきです。</p>

<p>例外規則の例: <i>"Who is afraid of Mrs. Woolf?"</i>(バージニアウルフなんてこわくない)は "<code>.</code>" の後ろで分節化されてはいけません。"<code>Mrs.</code>" のための例外規則があるべきです。</p>

<p>定義済みの分割規則はほとんどのヨーロッパ言語と日本語に対しては十分なはずですが、全ての言語に対して全ての例外規則を事前に定義するのは明らかに不可能なので、翻訳しようとしている言語のために更なる例外規則を定義することを薦めます。</p>

<a name="Rules_Setup"></a>
<h3>規則の設定</h3>

<p>規則を設定するには、メインメニューから<strong>設定 -&gt; 分節化...</strong>を選択します。プロジェクトを開いているときに分節化設定を変更した場合、変更を適用させるためにプロジェクトを再読み込みさせなければならないことに注意してください。</p>

<a name="Sets_of_Rules"></a>
<h4>規則セット</h4>

<p>一致する言語パターンについての分節化規則は、与えられた優先順に適用されますので、特定の言語のための規則はデフォルトのものより高い優先順を与えるべきです。</p>

<p>例えば、カナダフランス語（FR-CA）用の規則は、フランス語（FR.*）用の規則よりも優先され、更にデフォルト値（.*）よりも優先されます。そして、カナダフランス語から翻訳している間、プロジェクトは、この言語として定義された規則、フランス語の規則、デフォルトの規則を正しい順序で使用します。</p>

<p>空の規則セットを作成するために、ダイアログの上半分にある<strong>追加</strong>をクリックします。表の末尾に空行が現れます。規則セットの名前と言語パターンを変更します。言語パターンの文法は正規表現の文法に従います。以下の<a href="#Short_summary_of_regular-expression_constructs">正規表現構造の短い要約</a>の章を参照してください。</p>

<p>作成する規則セットが言語-地域ペアを扱う場合、<strong>上へ</strong> ボタンを使って先頭に移動させることを薦めます。</p>

<p>規則セットを編集するために、表の規則セットをクリックすると、ウィンドウの下半分に規則セットが現れます。</p>

<p>「分割/例外」チェックボックスは分割規則(セットした場合)なのか例外規則(セットしなかった場合)なのかを指定します。「分節前の構図」と「分節後の構図」の二つの正規表現は、分割規則か例外規則が成立するためにある場所の前後がどうなっていなければならないかを指定します。</p>

<p>分節化の処理は以下のように単純化されます。文書の最初の文字の後ろから最後の文字の前まで移動するカーソルを想像してください。それぞれのカーソル位置において、それぞれの規則を与えられた順序で取り出し、 <strong>分節前の構図</strong>がカーソルの左側にある文書全体について、 <strong>分節後の構図</strong>がカーソルの右側にある文書について適用できるかどうかを試します。</p>

<p>文書中の各位置において、規則の適用に成功した場合、それが例外規則なら、何も行ないませんがそれ以上規則を試すのを中止し、分割規則なら、左側の文書を分割した分節とします。</p>

<a name="Simple_examples"></a>
<h4>簡単な例</h4>

<p>
<dl>
   <dt><strong>目標:</strong> ピリオド('<code>.</code>')の後ろ、スペースの手前で分節を作る。</dt>
   <dd>分節前の構図: <code>\.</code> 分節後の構図: <code>\s</code> <br><strong>注意:</strong> "<code>\.</code>"は文字"<code>.</code>"を意味します。 <br>"<code>\s</code>"は任意の空白文字を意味します。</dd>

   <dt><strong>目標:</strong> "<code>Mr.<c/code>"の後ろで分節化しない。</dt>
   <dd>分節前の構図: <code>Mr\.</code> 分節後の構図: <code>\s</code> <br><strong>注意:</strong> 規則チェックボックスの<strong>チェックしない</strong>ままにすることを忘れないで下さい。
   </dd>

   <dt><strong>目標:</strong> "。" (日本語の句点)の後ろで分節化する。</dt>
   <dd>分節前の構図: 。 分節後の構図: (空) <br><strong>注意:</strong>フィールドを空のままにしておくこともできます。</dd>
</dl>
</p>

<a name="Regular_Expressions_to_use_in_segmentation_rules"></a>
<h3>分節化規則で使う正規表現</h3>

<p>分節化規則は正規表現で記述されています。これにより、規則の定義に最大限の柔軟性が与えられ、SRXにも従います。</p>

<a name="Short_summary_of_regular-expression_constructs"></a>
<h4>正規表現構造の短い要約</h4>

<p>これらは OmegaT の分節化規則に使われているだけではなく、とても一般的に使われている構造です。OmegaT は<a href="http://www.lisa.org/standards/srx/">SRX 標準</a> で記述されている全ての正規表現機能に対応しています。</p>

<table border="0" width="80%" cellpadding="1" cellspacing="0" summary="正規表現構造と、それらが何にマッチするか">
    <tr bgcolor="#DDEEFF"><th width="10%" align="left" id="construct">構造</th><th align="left">マッチ</th></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="flags">フラグ</th></tr>
    <tr><td><tt>(?i)</tt></td><td>マッチングの時に大文字小文字を区別しません (デフォルトでは、大文字小文字を区別します)。</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr><th align="left" colspan="2" id="characters">文字</th></tr>
    <tr><td><strong>x</strong></td><td>文字<strong>x</strong>そのものですが、以下のものは例外です...</td></tr>

    <tr><td><tt>\u</tt><strong>hhhh</strong></td><td>16 進数 <tt>0x</tt><strong>hhhh</strong>の値を持つ文字</td></tr>
    <tr><td><tt>\t</tt></td><td>タブ文字(<tt>'\u0009'</tt>)</td></tr>
    <tr><td><tt>\n</tt></td><td>改行文字(<tt>'\u000A'</tt>)</td></tr>

    <tr><td><tt>\r</tt></td><td>復帰文字(<tt>'\u000D'</tt>)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="quot">クォート</th></tr>
    <tr><td><tt>\</tt></td><td>どの文字も表しませんが、次の文字をクォートします。これはメタキャラクタ<code>!$()*+.&lt;&gt;?[\]^{|}</code>を、その文字そのものとマッチングさせたいときに必要です。</td></tr>

    <tr><td><tt>\\</tt></td><td>例えば、これはバックスラッシュ文字です。</td></tr>
    <tr><td><tt>\Q</tt></td><td>どの文字も表しませんが、<tt>\E</tt>までの全ての文字をクォートします。</td></tr>
    <tr><td><tt>\E</tt></td><td>どの文字も表しませんが、<tt>\Q</tt>から続くクォートを終了させます。</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="classes">文字クラス</th></tr>

    <tr><td><tt>[abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, <tt>c</tt>のいずれか (単純クラス)</td></tr>
    <tr><td><tt>[^abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, <tt>c</tt>以外の文字 (否定)</td></tr>

    <tr><td><tt>[a-zA-Z]</tt></td><td><tt>a</tt> から <tt>z</tt> または <tt>A</tt> から <tt>Z</tt>  (範囲)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="predef">定義済みの文字クラス</th></tr>

    <tr><td><tt>.</tt></td><td>(行末文字を除く)任意の文字</td></tr>
    <tr><td><tt>\d</tt></td><td>数値: <tt>[0-9]</tt></td></tr>
    <tr><td><tt>\D</tt></td><td>数字: <tt>[0-9]</tt></td></tr>
    <tr><td><tt>\s</tt></td><td>空白文字: <tt>[ \t\n\x0B\f\r]</tt></td></tr>

    <tr><td><tt>\S</tt></td><td>非空白文字: <tt>[^\s]</tt></td></tr>
    <tr><td><tt>\w</tt></td><td>単語文字: <tt>[a-zA-Z_0-9]</tt></td></tr>
    <tr><td><tt>\W</tt></td><td>非単語文字: <tt>[^\w]</tt></td></tr>
    <tr><th>&nbsp;</th></tr>

    <tr align="left"><th colspan="2" id="bounds">境界とマッチングするもの</th></tr>
    <tr><td><tt>^</tt></td><td>行頭</td></tr>
    <tr><td><tt>$</tt></td><td>行末</td></tr>
    <tr><td><tt>\b</tt></td><td>単語の区切り</td></tr>
    <tr><td><tt>\B</tt></td><td>単語の区切りでないもの</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="greedy">貪欲量指定子</th></tr>
    <tr><td colspan="2">これらはできるだけたくさんの文字とマッチングします。例えば、<code>a+</code> は <code>aaabbb</code> の中の <code>aaa</code> とマッチングします。</td></tr>
    <tr><td><strong>X</strong><tt>?</tt></td><td>0個か1個の<strong>X</strong></td></tr>

    <tr><td><strong>X</strong><tt>*</tt></td><td>0個以上の<strong>X</strong></td></tr>
    <tr><td><strong>X</strong><tt>+</tt></td><td>1個以上の<strong>X</strong></td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="reluc">無欲量指定子</th></tr>

    <tr><td colspan="2">これらはできるだけ少しの文字とマッチングします。例えば、<code>a+?</code> は<code>aaabbb</code>の中の最初の<code>a</code>とマッチングします。</td></tr>
    <tr><td><strong>X</strong><tt>??</tt></td><td>0個か1個の<strong>X</strong></td></tr>
    <tr><td><strong>X</strong><tt>*?</tt></td><td>0個以上の<strong>X</strong></td></tr>

    <tr><td><strong>X</strong><tt>+?</tt></td><td>1個以上の<strong>X</strong></td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="logical">論理演算子</th></tr>
    <tr><td><strong>XY</strong></td><td><strong>X</strong>に引き続いて<strong>Y</strong></td></tr>

    <tr><td><strong>X</strong><tt>|</tt><strong>Y</strong></td><td><strong>X</strong>か<strong>Y</strong>のどちらか</td></tr>
    <tr><td><tt>(</tt><strong>XY</strong><tt>)</tt></td><td><strong>XY</strong>を一つのグループとする</td></tr>

</table>

<hr>
<p><a href="legalNotices.html" title="特記事項">特記事項</a></p>

</body>
</html>