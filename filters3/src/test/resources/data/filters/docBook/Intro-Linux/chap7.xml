<?xml version='1.0' encoding='UTF-8'?>
<chapter id="chap_07"><title>Home sweet /home</title>
<abstract>
<para>This chapter is about configuring your environment.  Now that we now how to use an editor, we can change all kinds of files to make ourselves feel better at home.  After completing this chapter, you will know more about:</para>
<para>
<itemizedlist>
<listitem><para>Organizing your environment</para></listitem>
<listitem><para>Common shell setup files</para></listitem>
<listitem><para>Shell configuration</para></listitem>
<listitem><para>Configuring the prompt</para></listitem>
<listitem><para>Configuring the graphical environment</para></listitem>
<listitem><para>Sound and video applications</para></listitem>
<listitem><para>Display and window managers</para></listitem>
<listitem><para>How the X client-server system works</para></listitem>
<listitem><para>Language and font settings</para></listitem>
<listitem><para>Installing new software</para></listitem>
<listitem><para>Updating existing packages</para></listitem>
</itemizedlist>
</para>
</abstract>

<sect1 id="sect_07_01"><title>General good housekeeping</title>
<sect2 id="sect_07_01_01"><title>Introduction</title>
<para>As we mentioned before, it is easy enough to make a mess of the system.  We can't put enough stress on the importance of keeping the place tidy.  When you learn this from the start, it will become a good habit that will save you time when programming on a Linux or UNIX system or when confronted with system management tasks.  Here are some ways of making life easier<indexterm><primary>environment</primary><secondary>organization</secondary></indexterm> on yourself:</para>
<itemizedlist>
<listitem><para>Make a <filename>bin</filename> directory for your program files and scripts.</para></listitem>
<listitem><para>Organize non-executable files in appropriate directories, and make as many directories as you like.  Examples include separate directories for images, documents, projects, downloaded files, spreadsheets, personal files, and so on.</para></listitem>
<listitem><para>Make directories private with the <command>chmod <parameter>700</parameter> <filename>dirname</filename></command> command.</para></listitem>
<listitem><para>Give your files sensible names, such as <filename>Complaint to the prime minister 050302</filename> rather than <filename>letter1</filename>.</para></listitem>
</itemizedlist>
</sect2>
<sect2 id="sect_07_01_02"><title>Make space</title>
<para>On some systems, the <command>quota</command> system may force you to clean up from time to time, or the physical limits of your hard disk may force you to make more space without running any monitoring programs.  This section discusses a number of ways, besides using the <command>rm</command> command, to reclaim disk space.</para>
<para>Run the <command>quota <option>-v</option></command> command to see how much space is left.</para>
<sect3 id="sect_07_01_02_01"><title>Emptying files</title>
<para>Sometimes the content of a file doesn't interest you, but you need the file name as a marker (for instance, you just need the timestamp of a file, a reminder that the file was there or should be there some time in the future).  Redirecting the output of a null command<indexterm><primary>I/O redirection</primary><secondary>null command</secondary></indexterm> is how this is done in the <application>Bourne</application> and <application>Bash</application> shells<indexterm><primary>files</primary><secondary>emptying</secondary></indexterm>:</para>
<screen>
<prompt>andy:~&gt;</prompt> <command>cat wishlist &gt; placeholder</command>

<prompt>andy:~&gt;</prompt> <command>ls -la placeholder</command>
-rw-rw-r--    1 andy   andy       200 Jun 12 13:34 placeholder

<prompt>andy:~&gt;</prompt> <command> &gt; placeholder</command>

<prompt>andy:~&gt;</prompt> <command>ls -la placeholder</command>

-rw-rw-r--    1 andy   andy         0 Jun 12 13:35 placeholder
</screen>
<para>The process of reducing an existing file to a file with the same name that is 0 bytes large is called <emphasis>truncating<indexterm><primary>truncating</primary></indexterm></emphasis>.</para>
<para>For creating a new empty file, the same effect is obtained with the <command>touch<indexterm><primary>touch</primary></indexterm></command> command.  On an existing file, <command>touch</command> will only update the timestamp.  See the <application>Info</application> pages on <command>touch</command> for more details.</para>
<para>To <quote>almost</quote> empty a file, use the <command>tail<indexterm><primary>tail</primary></indexterm></command> command.  Suppose user <emphasis>andy</emphasis>'s wishlist becomes rather long because he always adds stuff at the end but never deletes the things he actually gets.  Now he only wants to keep the last five items:</para>
<screen>
<prompt>andy:~&gt;</prompt> <command>tail -5 wishlist &gt; newlist</command>

<prompt>andy:~&gt;</prompt> <command>cat newlist &gt; wishlist</command>

<prompt>andy:~&gt;</prompt> <command>rm newlist</command>
</screen>
</sect3>
<sect3 id="sect_07_01_02_02"><title>More about log files</title>
<para>Some Linux programs insist on writing all sorts of output in a log<indexterm><primary>files</primary><secondary>logs</secondary></indexterm> file.  Usually there are options to only log errors, or to log a minimal amount of information, for example setting the debugging level of the program.  But even then, you might not care about the log file.  Here are some ways to get rid of them or at least set some limits to their size:</para>
<itemizedlist>
<listitem><para>Try removing the log file when the program is not running, if you are sure that you won't need it again.  Some programs may even see, when restarted, that there is no log file and will therefore not log.</para></listitem>
<listitem><para>If you remove the log file and the program recreates it, read the documentation for this particular program in search for command options that avoid making log files.</para></listitem>
<listitem><para>Try making smaller log files by logging only the information that is relevant to you, or by logging only significant information.</para></listitem>
   <listitem><para>Try replacing the log file with a symbolic link to <filename>/dev/null</filename>; if you're lucky the program won't complain.  Don't do this with the log files of programs that run at system boot or programs that run from cron (see <xref linkend="chap_04" />).  These programs might replace the symbolic link with a small file that starts growing again.</para></listitem>
</itemizedlist>
</sect3>
<sect3 id="sect_07_01_02_03"><title>Mail</title>
<para>Regularly clean out your mailbox, make sub-folders and automatic redirects using <command>procmail</command> (see the <application>Info</application> pages) or the filters of your favorite mail reading application.  If you have a trash folder, clean it out on a regular basis.</para>
<para>To redirect mail, use the <filename>.forward<indexterm><primary>.forward</primary></indexterm></filename> file in your home directory.  The Linux mail service looks for this file whenever it has to deliver local mail.  The content of the file defines what the mail system should do with your mail.  It can contain a single line holding a fully qualified E-mail address.  In that case the system will send all your mail to this address.  For instance, when renting space for a website, you might want to forward the mail destined for the webmaster to your own account in order not to waste disk space.  The webmaster's <filename>.forward</filename> may look like this:</para>
<screen>
<prompt>webmaster@www ~/&gt;</prompt> <command>cat .forward</command>
mike@pandora.be
</screen>
<para>Using mail forwarding is also useful to prevent yourself from having to check several different mailboxes.  You can make every address point to a central and easily accessible account.</para>
<para>You can ask your system administrator to define a forward for you in the local mail aliases file, like when an account is being closed but E-mail remains active for a while.</para>
</sect3>
<sect3 id="sect_07_01_02_04"><title>Save space with a link</title>
<para>When several users need access to the same file or program, when the original file name is too long or too difficult to remember, use a symbolic<indexterm><primary>links</primary><secondary>saving space</secondary></indexterm> link instead of a separate copy for each user or purpose.</para>
<para>Multiple symbolic links may have different names, e.g. a link may be called <filename>monfichier</filename> in one user's directory, and <filename>mylink</filename> in another's.  Multiple links (different names) to the same file may also occur in the same directory.  This is often done in the <filename>/lib</filename> directory: when issuing the command</para>
<cmdsynopsis><command>ls <option>-l</option> <filename>/lib</filename></command></cmdsynopsis>
<para>you will see that this directory is plenty of links pointing to the same files.  These are created so that programs searching for one name would not get stuck, so they are pointed to the correct/current name of the libraries they need.</para>
</sect3>
<sect3 id="sect_07_01_02_05"><title>Limit file sizes</title>
<para>The shell contains a built-in command to limit file sizes, <command>ulimit<indexterm><primary>ulimit</primary></indexterm></command>, which can also be used to display limitations on system<indexterm><primary>files</primary><secondary>limit size</secondary></indexterm> resources:</para>
<screen>
<prompt>cindy:~&gt;</prompt> <command>ulimit -a</command>
core file size (blocks)     0
data seg size (kbytes)      unlimited
file size (blocks)          unlimited
max locked memory (kbytes)  unlimited
max memory size (kbytes)    unlimited
open files                  1024
pipe size (512 bytes)       8
stack size (kbytes)         8192
cpu time (seconds)          unlimited
max user processes          512
virtual memory (kbytes)     unlimited
</screen>
<para>Cindy is not a developer and doesn't care about core<indexterm><primary>files</primary><secondary>core dumps</secondary></indexterm> dumps, which contain debugging information on a program.  If you do want core dumps, you can set their size using the <command>ulimit</command> command.  Read the <application>Info</application> pages on <command>bash</command> for a detailed explanation.</para>
<note><title>Core file?</title>
<para>A core file or <emphasis>core dump</emphasis> is sometimes generated when things go wrong with a program during its execution.  The core file contains a copy of the system's memory, as it was at the time that the error occured.</para>
</note>
</sect3>
<sect3 id="sect_07_01_02_06"><title>Compressed files</title>
<para>Compressed files are useful because they take less space on your hard disk.  Another advantage is that it takes less bandwidth to send a compressed file over your network.  A lot of files, such as the man pages, are stored in a compressed format on your system.  Yet unpacking these to get a little bit of information and then having to compress them again is rather time-consuming.  You don't want to unpack a man page, for instance, read about an option to a command and then compress the man page again.  Most people will probably forget to clean up after they found the information they needed.</para>
<para>So we have tools that work on compressed files, by uncompressing them only in memory.  The actual compressed file stays on your disk as it is.  Most systems support <command>zgrep</command>, <command>zcat</command>, <command>bzless</command> and other members of the z-family to prevent unnecessary decompressing/compressing actions.  See your system's binary directory and the Info pages.</para>
<para>See <xref linkend="chap_09" /> for more on the actual compressing of files and examples on making archives.</para>

</sect3>
</sect2>

</sect1>
<sect1 id="sect_07_02"><title>Your text environment</title>
<sect2 id="sect_07_02_1"><title>Environment variables</title>
<sect3 id="sect_07_02_01"><title>General</title>
<para>We already mentioned a couple of environment variables, such as <varname>PATH</varname> and <varname>HOME</varname>.  Until now, we only saw examples in which they serve a certain purpose to the shell.  But there are many other Linux utilities that need information about you in order to do a good job.</para>
<para>What other information do programs need apart from paths and home directories?</para>  
<para>A lot of programs want to know about the kind of terminal you are using; this information is stored in the <varname>TERM<indexterm><primary>TERM</primary></indexterm></varname> variable.  In text mode, this will be the <emphasis>linux</emphasis> terminal emulation, in graphical mode you are likely to use <emphasis>xterm</emphasis>.  Lots of programs want to know what your favorite editor is, in case they have to start an editor in a subprocess.  The shell you are using is stored in the <varname>SHELL<indexterm><primary>SHELL</primary></indexterm></varname> variable, the operating system type in <varname>OS<indexterm><primary>OS</primary></indexterm></varname> and so on.  A list of all variables currently defined for your session can be viewed<indexterm><primary>environment</primary><secondary>show variables</secondary></indexterm> entering the <command>printenv<indexterm><primary>printenv</primary></indexterm></command> command.</para>
<para>The environment variables are managed by the shell.  As opposed to regular shell variables, environment variables are inherited by any program you start, including another shell.  New processes are assigned a copy of these variables, which they can read, modify and pass on in turn to their own child processes.</para>
<para>There is nothing special about variable names, except that the common ones are in upper case characters by convention.  You may come up with any name you want, although there are standard variables that are important enough to be the same on every Linux system, such as <varname>PATH</varname> and <varname>HOME</varname>.</para>
</sect3>
<sect3 id="sect_07_02_02"><title>Exporting variables</title>
<para>An individual variable's content<indexterm><primary>variables</primary><secondary>show content</secondary></indexterm> is usually displayed using the <command>echo<indexterm><primary>echo</primary></indexterm></command> command, as in these examples:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>echo $PATH</command>
/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin:/usr/local/bin

<prompt>debby:~&gt;</prompt> <command>echo $MANPATH</command>
/usr/man:/usr/share/man/:/usr/local/man:/usr/X11R6/man
</screen>
<para>If you want to change the content of a variable in a way that is useful to other programs, you have to export<indexterm><primary>variables</primary><secondary>export</secondary></indexterm> the new value from your environment into the environment that runs these programs.  A common example is exporting the <varname>PATH</varname> variable.  You may declare it as follows, in order to be able to play with the flight simulator software that is in <filename>/opt/FlightGear/bin</filename>:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>PATH=$PATH:/opt/FlightGear/bin</command>
</screen>
<para>This instructs the shell to not only search programs in the current path, <varname>$PATH</varname>, but also in the additional directory <filename>/opt/FlightGear/bin</filename>.</para>
<para>However, as long as the new value of the <varname>PATH</varname> variable is not known to the environment, things will still not work:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>runfgfs</command>
bash: runfgfs: command not found
</screen>
<para>Exporting variables is done using the shell built-in command <command>export<indexterm><primary>export</primary></indexterm></command>:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>export PATH</command>

<prompt>debby:~&gt;</prompt> <command>runfgfs</command>
--flight simulator starts--
</screen>
<para>In <application>Bash</application>, we normally do this in one elegant step:</para>
<cmdsynopsis><command>export <varname>VARIABLE</varname>=<replaceable>value</replaceable></command></cmdsynopsis>
<para>The same technique is used for the <varname>MANPATH<indexterm><primary>MANPATH</primary></indexterm></varname> variable, that tells the <command>man</command> command where to look for compressed man pages.  If new software is added to the system in new or unusual directories, the documentation for it will probably also be in an unusual directory.  If you want to read the man pages for the new software, extend the <varname>MANPATH</varname> variable:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>export MANPATH=$MANPATH:/opt/FlightGear/man</command>

<prompt>debby:~&gt;</prompt> <command>echo $MANPATH</command>
/usr/man:/usr/share/man:/usr/local/man:/usr/X11R6/man:/opt/FlightGear/man
</screen>
<para>You can avoid retyping this command in every window you open by adding it to one of your shell setup files, see <xref linkend="sect_07_02_04" />.</para>
</sect3>
<sect3 id="sect_07_02_03"><title>Reserved variables</title>
<para>The following table gives an overview of the most common<indexterm><primary>variables</primary><secondary>reserved variables</secondary></indexterm> predefined variables:</para>

<table frame="all">
<title>Common environment variables</title>
<tgroup cols="2" align="left" colsep="1" rowsep="1">
<thead>
<row><entry>Variable name</entry><entry>Stored information</entry></row>
</thead>
<tbody>
<row><entry><varname>DISPLAY<indexterm><primary>DISPLAY</primary></indexterm></varname></entry><entry>used by the X Window system to identify the display server</entry></row>
<row><entry><varname>DOMAIN<indexterm><primary>DOMAIN</primary></indexterm></varname></entry><entry>domain name</entry></row>
<row><entry><varname>EDITOR<indexterm><primary>EDITOR</primary></indexterm></varname></entry><entry>stores your favorite line editor</entry></row>
<row><entry><varname>HISTSIZE<indexterm><primary>HISTSIZE</primary></indexterm></varname></entry><entry>size of the shell history file in number of lines</entry></row>
<row><entry><varname>HOME<indexterm><primary>HOME</primary></indexterm></varname></entry><entry>path to your home directory</entry></row>
<row><entry><varname>HOSTNAME<indexterm><primary>HOSTNAME</primary></indexterm></varname></entry><entry>local host name</entry></row>
<row><entry><varname>INPUTRC<indexterm><primary>INPUTRC</primary></indexterm></varname></entry><entry>location of definition file for input devices such as keyboard</entry></row>
<row><entry><varname>LANG<indexterm><primary>LANG</primary></indexterm></varname></entry><entry>preferred language</entry></row>
<row><entry><varname>LD_LIBRARY_PATH<indexterm><primary>LD_LIBRARY_PATH</primary></indexterm></varname></entry><entry>paths to search for libraries</entry></row>
<row><entry><varname>LOGNAME<indexterm><primary>LOGNAME</primary></indexterm></varname></entry><entry>login name</entry></row>
<row><entry><varname>MAIL<indexterm><primary>MAIL</primary></indexterm></varname></entry><entry>location of your incoming mail folder</entry></row>
<row><entry><varname>MANPATH<indexterm><primary>MANPATH</primary></indexterm></varname></entry><entry>paths to search for man pages</entry></row>
<row><entry><varname>OS<indexterm><primary>OS</primary></indexterm></varname></entry><entry>string describing the operating system</entry></row>
<row><entry><varname>OSTYPE<indexterm><primary>OSTYPE</primary></indexterm></varname></entry><entry>more information about version etc.</entry></row>
<row><entry><varname>PAGER<indexterm><primary>PAGER</primary></indexterm></varname></entry><entry>used by programs like <command>man</command> which need to know what to do in case output is more than one terminal window.</entry></row>
<row><entry><varname>PATH<indexterm><primary>PATH</primary></indexterm></varname></entry><entry>search paths for commands</entry></row>
<row><entry><varname>PS1<indexterm><primary>PS1</primary></indexterm></varname></entry><entry>primary prompt</entry></row>
<row><entry><varname>PS2<indexterm><primary>PS2</primary></indexterm></varname></entry><entry>secondary prompt</entry></row>
<row><entry><varname>PWD<indexterm><primary>PWD</primary></indexterm></varname></entry><entry>present working directory</entry></row>
<row><entry><varname>SHELL<indexterm><primary>SHELL</primary></indexterm></varname></entry><entry>current shell</entry></row>
<row><entry><varname>TERM<indexterm><primary>TERM</primary></indexterm></varname></entry><entry>terminal type</entry></row>
<row><entry><varname>UID<indexterm><primary>UID</primary></indexterm></varname></entry><entry>user ID</entry></row>
<row><entry><varname>USER(NAME)<indexterm><primary>USER(NAME)</primary></indexterm></varname></entry><entry>user name</entry></row>
<row><entry><varname>VISUAL<indexterm><primary>VISUAL</primary></indexterm></varname></entry><entry>your favorite full-screen editor</entry></row>
<row><entry><varname>XENVIRONMENT<indexterm><primary>XENVIRONMENT</primary></indexterm></varname></entry><entry>location of your personal settings for X behavior</entry></row>
<row><entry><varname>XFILESEARCHPATH<indexterm><primary>XFILESEARCHPATH</primary></indexterm></varname></entry><entry>paths to search for graphical libraries</entry></row>
</tbody>
</tgroup>
</table>
<para>A lot of variables are not only predefined but also preset, using configuration files.  We discuss these in the next section.</para>
</sect3>
</sect2>

<sect2 id="sect_07_02_04"><title>Shell setup files</title>
<para>When entering the <command>ls <option>-al</option></command> command to get a long listing of all files, including the ones starting with a dot, in your home directory, you will see one or more files starting with a . and ending in <emphasis>rc</emphasis>.  For the case of <command>bash</command>, this is <filename>.bashrc<indexterm><primary>.bashrc</primary></indexterm></filename>.  This is the counterpart of the system-wide configuration file <filename>/etc/bashrc<indexterm><primary>bashrc</primary></indexterm></filename>.</para>
<para>When logging<indexterm><primary>shell</primary><secondary>configuration files</secondary></indexterm> into an interactive login shell, <command>login</command> will do the authentication, set the environment and start your shell.  In the case of <command>bash</command>, the next step is reading the general <filename>profile<indexterm><primary>profile</primary></indexterm></filename> from <filename>/etc</filename>, if that file exists.  <command>bash</command> then looks for <filename>~/.bash_profile<indexterm><primary>.bash_profile</primary><secondary></secondary></indexterm></filename>, <filename>~/.bash_login<indexterm><primary>.bash_login</primary></indexterm></filename> and <filename>~/.profile<indexterm><primary>.profile</primary></indexterm></filename>, in that order, and reads and executes commands from the first one that exists and is readable.  If none exists, <filename>/etc/bashrc</filename> is applied.</para>
<para>When a login shell exits, <command>bash</command> reads and executes commands from the file <filename>~/.bash_logout<indexterm><primary>.bash_logout</primary></indexterm></filename>, if it exists.
</para>
<para>This procedure is explained in detail in the <command>login<indexterm><primary>login</primary></indexterm></command> and <command>bash</command> man pages.</para>
</sect2>

<sect2 id="sect_07_02_05"><title>A typical set of setup files</title>
<sect3 id="sect_07_02_05_01"><title>/etc/profile example</title>
<para>Let's look<indexterm><primary>profile</primary><secondary>example</secondary></indexterm> at some of these config files.  First <filename>/etc/profile</filename> is read, in which important variables such as <varname>PATH</varname>, <varname>USER</varname> and <varname>HOSTNAME</varname> are set:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>cat /etc/profile</command>
# /etc/profile

# System wide environment and startup programs, for login setup
# Functions and aliases go in /etc/bashrc


# Path manipulation
if [ `id -u` = 0 ] &amp;&amp; ! echo $PATH | /bin/grep -q "/sbin" ; then
    PATH=/sbin:$PATH
fi

if [ `id -u` = 0 ] &amp;&amp; ! echo $PATH | /bin/grep -q "/usr/sbin" ; then
    PATH=/usr/sbin:$PATH
fi

if [ `id -u` = 0 ] &amp;&amp; ! echo $PATH | /bin/grep -q "/usr/local/sbin"
    then
    PATH=/usr/local/sbin:$PATH
fi

if ! echo $PATH | /bin/grep -q "/usr/X11R6/bin" ; then
    PATH="$PATH:/usr/X11R6/bin"
fi
</screen>
<para>These lines check the path to set: if <emphasis>root</emphasis> opens a shell (user ID 0), it is checked that <filename>/sbin</filename>, <filename>/usr/sbin</filename> and <filename>/usr/local/sbin</filename> are in the path.  If not, they are added.  It is checked for everyone that <filename>/usr/X11R6/bin</filename> is in the path.</para>

<screen>
# No core files by default
ulimit -S -c 0 &gt; /dev/null 2&gt;&amp;1
</screen>
<para>All trash goes to <filename>/dev/null</filename> if the user doesn't change this setting.</para>
<screen>
USER=`id -un`
LOGNAME=$USER
MAIL="/var/spool/mail/$USER"

HOSTNAME=`/bin/hostname`
HISTSIZE=1000
</screen>
<para>Here general variables are assigned their proper values.</para>
<screen>
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ]; then
    INPUTRC=/etc/inputrc
fi
</screen>
<para>If the variable <varname>INPUTRC</varname> is not set, and there is no <filename>.inputrc</filename> in the user's home directory, then the default input control file is loaded.  </para>
<screen>
export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE INPUTRC
</screen>
<para>All variables are exported, so that they are available to other programs requesting information about your environment.</para>
</sect3>
<sect3 id="sect_07_02_05_02"><title>The profile.d directory</title>
<screen>
for i in /etc/profile.d/*.sh ; do
    if [ -r $i ]; then
    	. $i
    fi
done
unset i
</screen>
<para>All readable shell scripts from the <filename>/etc/profile.d<indexterm><primary>profile.d</primary></indexterm></filename> directory are read and executed.  These do things like enabling <emphasis>color-ls</emphasis>, aliasing <command>vi</command> to <command>vim</command>, setting locales etc.  The temporary variable <varname>i</varname> is unset to prevent it from disturbing shell behavior later on.</para>
</sect3>
<sect3 id="sect_07_02_05_03"><title>.bash_profile example</title>
<para>Then <command>bash</command> looks for a <filename>.bash_profile</filename> in the user's home<indexterm><primary>.bash_profile</primary><secondary>example</secondary></indexterm> directory:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>cat .bash_profile </command>
#################################################################
#                                                               #
#   .bash_profile file                                          #
#                                                               #
#   Executed from the bash shell when you log in.               #
#                                                               #
#################################################################

source ~/.bashrc
source ~/.bash_login
</screen>
<para>This very straight forward file instructs your shell to first read <filename>~/.bashrc</filename> and then <filename>~/.bash_login</filename>.  You will encounter the <command>source<indexterm><primary>source</primary></indexterm></command> built-in shell command regularly when working in a shell environment: it is used to apply configuration changes to the current environment.</para>
</sect3>
<sect3 id="sect_07_02_05_04"><title>.bash_login example</title>
<para>The <filename>~/.bash_login</filename> file<indexterm><primary>.bash_login</primary><secondary>example</secondary></indexterm> defines default file protection by setting the <command>umask</command> value, see <xref linkend="sect_03_04_02_02" />.  The <filename>~/.bashrc</filename> file is used to define a bunch of user-specific aliases and functions and personal environment variables.  It first reads <filename>/etc/bashrc</filename>, which describes the default prompt (<varname>PS1</varname>) and the default umask value.  After that, you can add your own settings.  If no <filename>~/.bashrc</filename> exists, <filename>/etc/bashrc</filename> is read by default.</para>
</sect3>
<sect3 id="sect_07_02_05_05"><title>/etc/bashrc example</title>
<para>Your <filename>/etc/bashrc</filename> file<indexterm><primary>bashrc</primary><secondary>example</secondary></indexterm> might look like this:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>cat /etc/bashrc</command>
# /etc/bashrc

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# by default, we want this to get set.
# Even for non-interactive, non-login shells.
if [ `id -gn` = `id -un` -a `id -u` -gt 99 ]; then
	umask 002
else
	umask 022
fi
</screen>
<para>These lines set the <command>umask</command> value.  Then, depending on the type of shell, the prompt is set:</para>
<screen>
# are we an interactive shell?
if [ "$PS1" ]; then
  if [ -x /usr/bin/tput ]; then
    if [ "x`tput kbs`" != "x" ]; then 
# We can't do this with "dumb" terminal
      stty erase `tput kbs`
    elif [ -x /usr/bin/wc ]; then
      if [ "`tput kbs|wc -c `" -gt 0 ]; then 
# We can't do this with "dumb" terminal
        stty erase `tput kbs`
      fi
    fi
  fi
  case $TERM in
	xterm*)
	if [ -e /etc/sysconfig/bash-prompt-xterm ]; then
		PROMPT_COMMAND=/etc/sysconfig/bash-prompt-xterm
	else
   PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:\
${PWD/$HOME/~}\007"'
	fi
    ;;
	*)
   [ -e /etc/sysconfig/bash-prompt-default ] &amp;&amp; PROMPT_COMMAND=\
/etc/sysconfig/bash-prompt-default
	    ;;
    esac
    [ "$PS1" = "\\s-\\v\\\$ " ] &amp;&amp; PS1="[\u@\h \W]\\$ "
    
    if [ "x$SHLVL" != "x1" ]; then # We're not a login shell
        for i in /etc/profile.d/*.sh; do
	    if [ -x $i ]; then
	        . $i
	    fi
	done
    fi
fi
</screen>
</sect3>
<sect3 id="sect_07_02_05_06"><title>.bash_logout example</title>
<para>Upon logout, the commands in <filename>~/.bash_logout</filename> are<indexterm><primary>.bash_logout</primary><secondary>example</secondary></indexterm> executed, which can for instance clear the terminal, so that you have a clean window upon logging out of a remote session, or upon leaving the system console:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>cat .bash_logout</command>
# ~/.bash_logout

clear
</screen>
<para>Let's take a closer look at how these scripts work in the next section.  Keep <command>info <parameter>bash</parameter></command> close at hand.</para>
</sect3>
</sect2>
<sect2 id="sect_07_02_06"><title>The Bash prompt</title>
<sect3 id="sect_07_02_06_01"><title>Introduction</title>
<para>
The <application>Bash</application> prompt can do much more than displaying such simple information as your user name, the name of your machine and some indication about the present working directory.  We can add other information such as the current date and time, number of connected users etc.</para>
<para>Before we begin, however, we will save our current prompt<indexterm><primary>prompt</primary><secondary>backup</secondary></indexterm> in another environment variable:
</para>
<screen>
<prompt>[jerry@nowhere jerry]$</prompt> <command>MYPROMPT=$PS1</command>

<prompt>[jerry@nowhere jerry]$</prompt> <command>echo $MYPROMPT</command>
[\u@\h \W]\$

<prompt>[jerry@nowhere jerry]$</prompt>
</screen>
<para>When we change<indexterm><primary>prompt</primary><secondary>configuration</secondary></indexterm> the prompt now, for example by issuing the command <command><varname>PS1</varname>=<replaceable>"-&gt;"</replaceable></command>, we can always get our original prompt back with the command <command><varname>PS1</varname>=<varname>$MYPROMPT</varname></command>.  You will, of course, also get it back when you reconnect, as long as you just fiddle with the prompt on the command line and avoid putting it in a shell configuration file.</para>
</sect3>
<sect3 id="sect_07_02_06_02"><title>Some examples</title>
<para>In order to understand these prompts<indexterm><primary>prompt</primary><secondary>examples</secondary></indexterm> and the escape sequences used, we refer to the <application>Bash Info</application> or man pages.</para>
<itemizedlist>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"[\t \j] "</replaceable></command></para><para>Displays time of day and number of running jobs</para>
</listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"[\d][\u@\h \w] : "</replaceable></command></para><para>Displays date, user name, host name and current working directory.  Note that \W displays only base names of the present working directory.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"{\!} "</replaceable></command></para><para>Displays history number for each command.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[1;35m\]\u@\h\[\033[0m\] "</replaceable></command></para><para>Displays user@host in pink.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[1;35m\]\u\[\033[0m\] \[\033[1;34m\]\w\[\033[0m\] "</replaceable></command></para><para>Sets the user name in pink and the present working directory in blue.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[1;44m\]$USER is in \w\[\033[0m\] "</replaceable></command></para><para>Prompt for people who have difficulties seeing the difference between the prompt and what they type.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[4;34m\]\u@\h \w \[\033[0m\]"</replaceable></command></para><para>Underlined prompt.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[7;34m\]\u@\h \w \[\033[0m\] "</replaceable></command></para><para>White characters on a blue background.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=<replaceable>"\[\033[3;35m\]\u@\h \w \[\033[0m\]\a"</replaceable></command></para><para>Pink prompt in a lighter font that alerts you when your commands have finished.</para></listitem>
<listitem><para><command>export <varname>PS1</varname>=...</command></para></listitem>
</itemizedlist>
<para>Variables are exported so the subsequently executed commands will also know about the environment.  The prompt configuration line that you want is best put in your shell configuration file, <filename>~/.bashrc<indexterm><primary>.bashrc</primary></indexterm></filename>.</para>
<para>If you want, prompts can execute shell scripts and behave different under different conditions.  You can even have the prompt play a tune every time you issue a command, although this gets boring pretty soon.  More information can be found in the <ulink url="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/">Bash-Prompt HOWTO</ulink>.</para>
</sect3>
</sect2>
<sect2 id="sect_07_02_07"><title>Shell scripts</title>
<sect3 id="sect_07_02_07_01"><title>What are scripts?</title>
<para>A shell<indexterm><primary>shell</primary><secondary>scripts</secondary></indexterm> script is, as we saw in the shell configuration examples, a text file containing shell commands.  When such a file is used as the first non-option argument when invoking <application>Bash</application>, and neither the <option>-c</option> nor <option>-s</option> option is supplied, <application>Bash</application> reads and executes commands from the file, then exits.  This mode of operation creates a non-interactive shell.  When <application>Bash</application> runs a shell script, it sets the special parameter <varname>0</varname> to the name of the file, rather than the name of the shell, and the positional parameters (everything following the name of the script) are set to the remaining arguments, if any are given.  If no additional arguments are supplied, the positional parameters are unset.</para>
<para>A shell script may be made executable by using the <command>chmod<indexterm><primary>scripts</primary><secondary>chmod</secondary></indexterm></command> command to turn on the execute bit.  When <application>Bash</application> finds such a file while searching the <varname>PATH</varname> for a command, it spawns a sub-shell to execute it.  In other words, executing</para>
<cmdsynopsis><command>filename <parameter>ARGUMENTS</parameter></command></cmdsynopsis>
<para>is equivalent to executing</para>
<cmdsynopsis><command>bash <parameter>filename</parameter> <parameter>ARGUMENTS</parameter></command></cmdsynopsis>
<para>if <quote>filename</quote> is an executable shell script.  This sub-shell reinitializes itself, so that the effect is as if a new shell had been invoked to interpret the script, with the exception that the locations of commands remembered by the parent (see <command>hash</command> in the <application>Info</application> pages) are retained by the child.</para>
<para>Most versions of UNIX make this a part of the operating system's command execution mechanism.  If the first line of a script begins with the two characters <quote>#!</quote>, the remainder of the line specifies an interpreter for the program.  Thus, you can specify <command>bash</command>, <command>awk</command>, <command>perl</command> or some other interpreter or shell and write the rest of the script file in that language.</para>
<para>The arguments to the interpreter consist of a single optional argument following the interpreter name on the first line of the script file, followed by the name of the script file, followed by the rest of the arguments.  <application>Bash</application> will perform this action on operating systems that do not handle it themselves.</para>
<para><application>Bash</application> scripts often begin<indexterm><primary>script</primary><secondary>first line</secondary></indexterm> with</para>
<screen>
#! /bin/bash
</screen>
<para>(assuming that <application>Bash</application> has been installed in <filename>/bin</filename>), since this ensures that <application>Bash</application> will be used to interpret the script, even if it is executed under another shell.</para>
</sect3>
<sect3 id="sect_07_02_07_02"><title>Some simple examples</title>
<para>A very simple<indexterm><primary>script</primary><secondary>example</secondary></indexterm> script consisting of only one command, that says hello to the user executing it:</para>
<screen>
<prompt>[jerry@nowhere ~]</prompt> <command>cat hello.sh</command>
#!/bin/bash
echo "Hello $USER"
</screen>
<para>The script actually consists of only one command, <command>echo</command>, which uses the <emphasis>value of</emphasis> ($) the <varname>USER</varname> environment variable to print a string customized to the user issuing the command.</para>
<para>Another one-liner, used for displaying connected users:</para>
<screen>
#!/bin/bash
who | cut -d " " -f 1 | sort -u
</screen>
<para>Here is a script consisting of some more lines, that I use to make backup copies of all files in a directory.  
The script first makes a list of all the files in the current directory and puts it in the variable <varname>LIST</varname>.  Then it sets the name of the copy for each file, and then it copies the file.  For each file, a message is printed:</para>
<screen>
<prompt>tille:~&gt;</prompt> <command>cat <filename>bin/makebackupfiles.sh</filename></command>
#!/bin/bash
# make copies of all files in a directory
LIST=`ls`
for i in $LIST; do
	ORIG=$i
	DEST=$i.old
	cp $ORIG $DEST
	echo "copied $i"
done
</screen>
<para>Just entering a line like <command>mv <parameter>*</parameter> <parameter>*.old</parameter></command> won't work, as you will notice when trying this on a set of test files.  An <command>echo</command> command was added in order to display some activity.  <command>echo</command>'s are generally useful when a script won't work: insert one after each doubted step and you will find the error in no time.</para>
<para>The <filename>/etc/rc.d/init.d</filename> directory contains loads of examples.  Let's look at this script that controls<indexterm><primary>script</primary><secondary>init script example</secondary></indexterm> the fictive ICanSeeYou server:</para>
<screen>
#!/bin/sh
# description: ICanSeeYou allows you to see networked people

# process name: ICanSeeYou
# pidfile: /var/run/ICanSeeYou/ICanSeeYou.pid
# config: /etc/ICanSeeYou.cfg

# Source function library.
. /etc/rc.d/init.d/functions

# See how (with which arguments) we were called.
case "$1" in
	start)
		echo -n "Starting ICanSeeYou: "
		daemon ICanSeeYou
		echo
		touch /var/lock/subsys/ICanSeeYou
		;;
	stop)
		echo -n "Shutting down ICanSeeYou: "
		killproc ICanSeeYou
		echo
		rm -f /var/lock/subsys/ICanSeeYou
		rm -f /var/run/ICanSeeYou/ICanSeeYou.pid
		;;
	status)
		status ICanSeeYou
		;;
	restart)
		$0 stop
		$0 start
		;;
	*)
		echo "Usage: $0 {start|stop|restart|status}"
		exit 1
esac

exit 0
</screen>
<para>First, with the <command>.</command> command (dot) a set of shell functions, used by almost all shell scripts in <filename>/etc/rc.d/init.d</filename>, is loaded.  Then a <command>case</command> command is issued, which defines 4 different ways the script can execute.  An example might be <command>ICanSeeYou <parameter>start</parameter></command>.  The decision of which case to apply is made by reading the (first) argument to the script, with the expression <emphasis>$1</emphasis>.</para>
<para>When no compliant input is given, the default case, marked with an asterisk, is applied, upon which the script gives an error message.  The <command>case</command> list is ended with the <command>esac</command> statement.  In the <emphasis>start</emphasis> case the server program is started as a daemon, and a process ID and lock are assigned.  In the <emphasis>stop</emphasis> case, the server process is traced down and stopped, and the lock and the PID are removed.  Options, such as the <option>daemon</option> option, and functions like <option>killproc</option>, are defined in the <filename>/etc/rc.d/init.d/functions</filename> file.  This setup is specific to the distribution used in this example.  The initscripts on your system might use other functions, defined in other files, or none at all.</para>
<para>Upon success, the script returns an exit code of zero to its parent.</para>
<para>
This script is a fine example of using functions, which make the script easier to read and the work done faster.  Note that they use <command>sh</command> instead of <command>bash</command>, to make them useful on a wider range of systems.  On a Linux system, calling <command>bash</command> as <command>sh</command> results in the shell running in POSIX-compliant mode.</para>

<para>The <command>bash</command> man pages contain more information about combining commands, <command>for</command>- and <command>while</command>-loops and regular expressions, as well as examples.  A comprehensible <application>Bash</application> course for system administrators and power users, with exercises, from the same author as this Introduction to Linux guide, is at <ulink url="http://tille.garrels.be/training/bash/">http://tille.garrels.be/training/bash/</ulink>.  Detailed description of <application>Bash</application> features and applications is in the reference guide <ulink url="http://tldp.org/LDP/abs/html/index.html">Advanced Bash Scripting</ulink>.</para>
</sect3>
</sect2>

</sect1>
<sect1 id="sect_07_03"><title>The graphical environment</title>
<sect2 id="sect_07_03_01"><title>Introduction</title>
<para>The average user may not care too much about his login settings, but Linux offers a wide variety of flashy window and desktop managers for use under X, the graphical<indexterm><primary>environment</primary><secondary>graphical</secondary></indexterm> environment.  The use and configuration of window managers and desktops is straightforward and may even resemble the standard MS Windows, Apple or UNIX CDE environment, although many Linux users prefer flashier desktops and fancier window managers.  We won't discuss the user specific configuration here.  Just experiment and read the documentation using the built-in Help functions these managers provide and you will get along fine.</para>
<para>We will, however, take a closer look at the underlying system.</para>


</sect2>
<sect2 id="sect_07_03_02"><title>The X Window System</title>
<para>The X Window<indexterm><primary>X Window</primary><secondary>definition</secondary></indexterm> System is a network-transparent window system which runs on a wide range of computing and graphics machines.  X Window System servers run on computers with bitmap displays.  The X server distributes user input to and accepts output requests from several client<indexterm><primary>X Window</primary><secondary>clients</secondary></indexterm> programs through a variety of different interprocess communication channels.  Although the most common case is for the client programs to be running on the same machine as the server, clients can be run transparently from other machines (including machines with different architectures and operating systems) as well.  We will learn how to do this in <xref linkend="chap_10" /> on networking and remote applications.</para>
<para>X supports overlapping hierarchical sub-windows and text and graphics operations, on both monochrome and color displays.  The number of X client programs that use the X server is quite large.  Some of the programs provided in the core X Consortium<indexterm><primary>X Window</primary><secondary>application overview</secondary></indexterm> distribution include:</para>
<itemizedlist>
<listitem><para><command>xterm</command>: a terminal emulator</para></listitem>
<listitem><para><command>twm</command>: a minimalistic window manager</para></listitem>
<listitem><para><command>xdm</command>: a display manager</para></listitem>
<listitem><para><command>xconsole</command>: a console redirect program</para></listitem>
<listitem><para><command>bitmap</command>: a bitmap editor</para></listitem>
<listitem><para><command>xauth</command>, <command>xhost</command> and <command>iceauth</command>: access control programs</para></listitem>
<listitem><para><command>xset</command>, <command>xmodmap</command> and many others: user preference setting programs</para></listitem>
<listitem><para><command>xclock</command>: a clock</para></listitem>
<listitem><para><command>xlsfonts</command> and others: a font displayer, utilities for listing information about fonts, windows and displays</para></listitem>
<listitem><para><command>xfs</command>: a font server</para></listitem>
<listitem><para>...</para></listitem>
</itemizedlist>
<para>We refer again to the man pages of these commands for detailed information.  More explanations on available functions can be found in the <emphasis>Xlib - C language X Interface</emphasis> manual that comes with your X distribution, the <emphasis>X Window System Protocol</emphasis> specification, and the various manuals and documentation of X toolkits.  The <filename>/usr/share/doc</filename> directory contains references to these documents and many others.</para>
<para>Many other utilities, window managers, games, toolkits and gadgets are included as user-contributed software in the X Consortium distribution, or are available using anonymous FTP on the Internet.  Good places to start are <ulink url="http://www.x.org">http://www.x.org</ulink> and <ulink url="http://www.xfree.org">http://www.xfree.org</ulink>.</para>
<para>Furthermore, all your graphical applications, such as your browser, your E-mail program, your image viewing programs, sound playing tools and so on, are all clients to your X server.  Note that in normal operation, that is in graphical mode, X clients and the X server on Linux run on the same machine.</para>
<sect3 id="sect_07_03_02_01"><title>Display names</title>
<para>From the user's perspective, every X server<indexterm><primary>X Window</primary><secondary>display names</secondary></indexterm> has a <emphasis>display name</emphasis> in the form of:</para> 
<cmdsynopsis><command><parameter>hostname</parameter>:<parameter>displaynumber</parameter>.<parameter>screennumber</parameter></command></cmdsynopsis>
<para>This information is used by the application to determine how it should connect to the X server and which screen it should use by default (on displays with multiple monitors):</para>
<itemizedlist>
<listitem><para><emphasis>hostname<indexterm><primary>X Window</primary><secondary>hostname</secondary></indexterm></emphasis>: The host name specifies the name of the client machine to which the display is physically connected.  If the host name is not given, the most efficient way of communicating to a server on the same machine will be used.</para></listitem>
<listitem><para><emphasis>displaynumber<indexterm><primary>X Window</primary><secondary>display number</secondary></indexterm></emphasis>: The phrase <quote>display</quote> is usually used to refer to a collection of monitors that share a common key board and pointer (mouse, tablet, etc.).  Most workstations  tend  to only have one keyboard, and therefore, only one display.  Larger, multi-user systems, however, frequently have several displays so that more than one person can be doing graphics work at once.  To avoid confusion, each display on a machine is assigned a <emphasis>display number</emphasis> (beginning at 0) when the X server for that display is started.  The display number must always be given in a display name.</para></listitem>
<listitem><para><emphasis>screen number<indexterm><primary>X Window</primary><secondary>screen number</secondary></indexterm></emphasis>: Some displays share a single keyboard and pointer among two or more monitors.  Since each monitor has its own set of windows, each screen is assigned a <emphasis>screen number</emphasis> (beginning at 0) when the X server for that display is started.  If the screen number is not given, screen 0 will be used.</para></listitem>
</itemizedlist>
<para>On POSIX systems, the default display name is stored in your <varname>DISPLAY<indexterm><primary>DISPLAY</primary></indexterm></varname> environment variable.  This variable is set automatically by the <command>xterm</command> terminal emulator.  However, when you log into another machine on a network, you might need to set <varname>DISPLAY</varname> by hand to point to your display, see <xref linkend="sect_10_05_03_02" />.</para>
<para>More information can be found in the X man pages.</para>
</sect3>
<sect3 id="sect_07_03_02_02"><title>Window and desktop managers</title>
<para>The layout of windows on the screen is controlled by special programs called <emphasis>window managers<indexterm><primary>window manager</primary></indexterm></emphasis>.  Although many window managers will honor geometry specifications as given, others may choose to ignore them (requiring the user to explicitly draw the window's region on the screen with the pointer, for example).</para>
<para>Since window managers are regular (albeit complex) client programs, a variety of different user interfaces can be built.  The X Consortium distribution comes with a window manager named <command>twm</command>, but most users prefer something more fancy when system resources permit.  Sawfish and Enlightenment are popular examples which allow each user to have a desktop according to mood and style.</para>
<para>A desktop manager makes use of one window manager or another for arranging your graphical desktop in a convenient way, with menubars, drop-down menus, informative messages, a clock, a program manager, a file manager and so on.  Among the most popular desktop managers are <application>Gnome</application> and <application>KDE</application>, which both run on almost any Linux distribution and many other UNIX systems.</para>
<tip><title>KDE applications in Gnome/Gnome applications in KDE</title>
<para>You don't need to start your desktop in <application>KDE</application> in order to be able to run <application>KDE</application> applications.  If you have the <application>KDE</application> libraries installed (the <application>kdelibs</application> package), you can run these applications from the <application>Gnome</application> menus or start them from a <application>Gnome</application> terminal.</para>
<para>Running <application>Gnome</application> applications in a <application>KDE</application> environment is a bit more tricky, because there is no single set of base-libraries in <application>Gnome</application>.  However, the dependencies and thus extra packages you might have to install will become clear when running or installing such an application.</para>
</tip> 

</sect3>
</sect2>
<sect2 id="sect_07_03_03"><title>X server configuration</title>
<para>The X<indexterm><primary>X Window</primary><secondary>configuration</secondary></indexterm> distribution that used to come with Linux, <emphasis>XFree86</emphasis>, uses the configuration file <filename>XF86Config</filename> for its initial setup.  This file configures your video card and is searched for in a number of locations, although it is usually in <filename>/etc/X11</filename>.</para>
<para>If you see that the file <filename>/etc/X11/XF86Config<indexterm><primary>XF86Config</primary></indexterm></filename> is present on your system, a full description can be found in the <application>Info</application> or man pages about <filename>XF86Config</filename>.</para>
<para>Because of licensing issues with XFree86, newer systems usually come with the <emphasis>X.Org<indexterm><primary>X.Org</primary></indexterm></emphasis> distribution of the X server and tools.  The main configuration file here is <filename>xorg.conf<indexterm><primary>xorg.conf</primary></indexterm></filename>, usually also in <filename>/etc/X11</filename>.  The file consists of a number of sections that may occur in any order.  The sections contain information about your monitor, your video adaptor, the screen configuration, your keyboard etcetera.  As a user, you needn't worry too much about what is in this file, since everything is normally determined at the time the system is installed.</para>
<para>Should you need to change graphical server settings, however, you can run the configuration tools or edit the configuration files that set up the infrastructure to use the XFree86 server.  See the man pages for more information; your distribution might have its own tools.  Since misconfiguration may result in unreadable garbage in graphical mode, you may want to make a backup copy of the configuration file before attempting to change it, just to be on the safe side.</para>
</sect2>

</sect1>
<sect1 id="sect_07_05"><title>Region specific settings</title>
<sect2 id="sect_07_05_01"><title>Keyboard setup</title>
<para>Setting the <indexterm><primary>keyboard</primary><secondary>layout</secondary></indexterm>keyboard layout is done using the <command>loadkeys<indexterm><primary>loadkeys</primary></indexterm></command> command for text consoles.  Use your local X configuration tool or edit the <emphasis>Keyboard</emphasis> section in <filename>XF86Config<indexterm><primary>XF86Config</primary><secondary>KeyBoard</secondary></indexterm></filename> manually to configure the layout for graphical mode.  The <varname>XkbdLayout<indexterm><primary>keyboard</primary><secondary>XkbdLayout</secondary></indexterm></varname> is the one you want to set:</para>
<screen>
    XkbLayout       "us"
</screen>
<para>This is the default.  Change it to your local settings by replacing the quoted value with any of the names listed in the subdirectories of your <filename>keymaps</filename> directory.  If you can't find the keymaps, try displaying their location on your system issuing the command</para>
<cmdsynopsis><command>locate <filename>keymaps</filename></command></cmdsynopsis>
<para>It is possible to combine layout settings, like in this example:</para>
<screen>
Xkblayout      "us,ru"
</screen>
<para>Make a backup of the <filename>/etc/X11/XF86Config</filename> file before editing it!  You will need to use the <emphasis>root</emphasis> account to do this.</para>
<para>Log out and reconnect in order to reload X settings.</para>
<para>The <application>Gnome Keyboard Applet</application> enables real-time switching<indexterm><primary>KeyBoard</primary><secondary>switching layouts</secondary></indexterm> between layouts; no special pemissions are needed for using this program.  <application>KDE</application> has a similar tool for switching between keyboard layouts.</para>
</sect2>
<sect2 id="sect_07_05_02"><title>Fonts</title>
<para>Use<indexterm><primary>fonts</primary><secondary>configuration</secondary></indexterm> the <command>setfont<indexterm><primary>setfont</primary></indexterm></command> tool to load fonts in text mode.  Most systems come with a standard <filename>inputrc<indexterm><primary>inputrc</primary></indexterm></filename> file which enables combining of characters, such as the French <quote>&#233;</quote> (meta characters).  The system admin should then add the line</para>
<screen>
export INPUTRC="/etc/inputrc"
</screen>
<para>to the <filename>/etc/bashrc</filename> file.</para>  

</sect2>
<sect2 id="sect_07_05_03"><title>Date and time zone</title>
<para>Setting time information<indexterm><primary>date</primary><secondary>configuration</secondary></indexterm> is usually done at installation time.  After that, it can be kept up to date using an <emphasis>NTP<indexterm><primary>NTP</primary></indexterm></emphasis> (Network Time Protocol) client.  Most Linux systems run <command>ntpd</command> by default:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>ps -ef | grep ntpd</command>
ntp      24678     1  0  2002 ?        00:00:33 ntpd -U ntp
</screen>
<para>You can run <command>ntpdate<indexterm><primary>ntpdate</primary></indexterm></command> manually to set the time, on condition that you can reach a time server.  The <command>ntpd</command> daemon should not be running when you adjust the time using <command>ntpdate</command>.  Use a time server as argument to the command:</para>
<screen>
<prompt>root@box:~# </prompt><command>ntpdate <parameter>10.2.5.200</parameter></command>
26 Oct 14:35:42 ntpdate[20364]: adjust time server 10.2.5.200 offset
 -0.008049 sec
</screen>
<para>See your system manual and the documentation that comes with the NTP package.  Most desktop managers include tools to set the system time, providing that you have access to the system administrator's account.</para>
<para>For setting the time zone<indexterm><primary>time zone</primary><secondary>configuration</secondary></indexterm> correct, you can use <command>tzconfig<indexterm><primary>tzconfig</primary></indexterm></command> or <command>timezone<indexterm><primary>timezone</primary></indexterm></command> commands.  Timezone information is usually set during the installation of your machine.  Many systems have distribution-specific tools to configure it, see your system documentation.</para>
</sect2>
<sect2 id="sect_07_05_04"><title>Language</title>
<para>If you'd rather get your messages<indexterm><primary>messages</primary><secondary>language</secondary></indexterm> from the system in Dutch or French, you may want to set the <varname>LANG<indexterm><primary>LANG</primary></indexterm></varname> and <varname>LANGUAGE<indexterm><primary>LANGUAGE</primary></indexterm></varname> environment variables, thus enabling locale support for the desired language and eventually the fonts related to character conventions in that language.</para>
<para>With most graphical login<indexterm><primary>login</primary><secondary>language configuration</secondary></indexterm> systems, such as <command>gdm</command> or <command>kdm</command>, you have the possibility to configure these language settings before logging in.</para>
<para>Note that on most systems, the default tends to be <emphasis>en_US.UTF-8<indexterm><primary>character encoding</primary></indexterm></emphasis> these days.  This is not a problem, because systems where this is the default, will also come with all the programs supporting this encoding.  Thus, <command>vi</command> can edit all the files on your system, <command>cat</command> won't behave strange and so on.</para>
<para>Trouble starts when you connect to an older system not supporting this font encoding, or when you open a <emphasis>UTF-8<indexterm><primary>UTF-8</primary></indexterm></emphasis> encoded file on a system supporting only 1-byte character fonts.  The <command>recode<indexterm><primary>recode</primary></indexterm></command> utility might come in handy to convert files from one character set to another.  Read the man pages for an overview of features and usage.  Another solution might be to temporarily work with another encoding definition, by setting the <varname>LANG</varname> environment variable:</para>
<screen>
<prompt>debby:~&gt;</prompt> <command>acroread /var/tmp/51434s.pdf</command>
Warning: charset "UTF-8" not supported, using "ISO8859-1".
Aborted

<prompt>debby:~&gt;</prompt> <command>set | grep UTF</command>
LANG=en_US.UTF-8

<prompt>debby:~&gt;</prompt> <command>export LANG=en_US</command>

<prompt>debby:~&gt;</prompt> <command>acroread /var/tmp/51434s.pdf</command>
&lt;--new window opens--&gt;
</screen>
<para>Refer to the <ulink url="http://www.mozilla.org/">Mozilla</ulink> web site for guidance on how to get <application>Firefox</application> in your language.  The <ulink url="http://www.openoffice.org/">OpenOffice.org</ulink> web site has information on localization of your <application>OpenOffice.org</application> suite.</para>
</sect2>
<sect2 id="sect_07_05_06"><title>Country-specific Information</title>
<para>The <ulink url="http://www.tldp.org/HOWTO/HOWTO-INDEX/howtos.html">list of HOWTOs</ulink> contains references to Bangla, Belarusian, Chinese, Esperanto, Finnish, Francophone, Hebrew, Hellenic, Latvian, Polish, Portugese, Serbian, Slovak, Slovenian, Spanish, Thai and Turkish localization instructions.</para> 
</sect2>

</sect1>
<sect1 id="sect_07_06"><title>Installing new software</title>
<sect2 id="sect_07_06_01"><title>General</title>
<para>Most people are surprised to see that they have a running, usable computer after installing Linux; most distributions contain ample support for video and network cards, monitors and other external devices, so there is usually no need to install extra drivers.  Also common tools such as office suites, web browsers, E-mail and other network client programs are included in the main distributions.  Even so, an initial installation might not meet your requirements.</para>
<para>If you just can't find<indexterm><primary>software</primary><secondary>installing</secondary></indexterm> what you need, maybe it is not installed on your system.  It may also be that you have the required software, but it does not do what it is supposed to do.  Remember that Linux moves fast, and software improves on a daily basis.  Don't waste your time troubleshooting problems that might already be resolved.</para>
<para>You can update your system or add packages to it at any time you want.  Most software comes in packages.  Extra software may be found on your installation CDs or on the Internet.  The website of your Linux distribution is a good place to start looking for additional software and contains instructions about how to install it on your type of Linux, see <xref linkend="app1" />.  Always read the documentation that comes with new software, and any installation guidelines the package might contain.  All software comes with a <filename>README<indexterm><primary>README</primary></indexterm></filename> file, which you are very strongly advised to read.</para>
</sect2>

<sect2 id="sect_07_06_02"><title>Package formats</title>
<sect3 id="sect_07_06_02_01"><title>RPM packages</title>
<sect4 id="sect_07_06_02_01_01"><title>What is RPM?</title>
<para>RPM, the <application>RedHat Package Manager<indexterm><primary>packages</primary><secondary>RPM</secondary></indexterm></application>, is a powerful package manager that you can use to install, update and remove packages.  It allows you to search for packages and keeps track of the files that come with each package.  A system is built-in so that you can verify the authenticity of packages downloaded from the Internet.  Advanced users can build their own packages with RPM.</para>
<para>An RPM package  consists  of an archive of files and meta-data used to install and erase the archive files. The meta-data includes  helper  scripts,  file attributes,  and  descriptive  information about the package.  Packages come in two varieties: binary packages, used to encapsulate software to be  installed,  and source  packages,  containing  the source code and recipe necessary to produce binary packages.</para>
<para>Many other distributions support RPM packages, among the popular ones RedHat Enterprise Linux, Mandriva (former Mandrake), Fedora Core and SuSE Linux.  Apart from the advice for your distribution, you will want to read <command>man <parameter>rpm</parameter></command>.</para>
</sect4>
<sect4 id="sect_07_06_02_01_02"><title>RPM examples</title>
<para>Most packages are simply installed with the upgrade option, <option>-U</option>, whether the package is already installed or not.  The RPM package contains a complete<indexterm><primary>packages</primary><secondary>install RPM</secondary></indexterm> version of the program, which overwrites existing versions or installs as a new package.  The typical usage<indexterm><primary>RPM</primary><secondary>installation</secondary></indexterm> is as follows:</para>
<cmdsynopsis><command>rpm <option>-Uvh</option> <filename>/path/to/rpm-package(s)</filename></command></cmdsynopsis>
<para>The <option>-v</option> option generates more verbose output, and <option>-h</option> makes <command>rpm</command> print a progress bar:</para>
<screen>
<prompt>[root@jupiter tmp]#</prompt> <command>rpm -Uvh totem-0.99.5-1.fr.i386.rpm</command>
Preparing...                ########################################### [100%]
   1:totem                  ########################################### [100%]
<prompt>[root@jupiter tmp]#</prompt>
</screen>
<para>New kernel packages, however, are installed with the install option <option>-i</option>, which does not overwrite existing version(s) of the package. That way, you will still be able to boot your system with the old kernel if the new one does not work.</para>
<para>You can also use <command>rpm<indexterm><primary>rpm</primary></indexterm></command> to check whether a package is installed<indexterm><primary>RPM</primary><secondary>search packages</secondary></indexterm> on your system:</para>
<screen>
<prompt>[david@jupiter ~]</prompt> <command>rpm -qa | grep vim</command>
vim-minimal-6.1-29
vim-X11-6.1-29
vim-enhanced-6.1-29
vim-common-6.1-29
</screen> 
<para>Or you can find out which package contains a certain file<indexterm><primary>RPM</primary><secondary>search files</secondary></indexterm> or executable:</para>
<screen>
<prompt>[david@jupiter ~]</prompt> <command>rpm -qf /etc/profile</command>
setup-2.5.25-1

<prompt>[david@jupiter ~]</prompt> <command>which cat</command>
cat is /bin/cat

<prompt>[david@jupiter ~]</prompt> <command>rpm -qf /bin/cat</command>
coreutils-4.5.3-19
</screen>
<para>Note that you need not have access to administrative privileges in order to use <command>rpm</command> to query the RPM database.  You only need to be <emphasis>root</emphasis> when adding, modifying or deleting packages.</para>
<para>Below is one last example, demonstrating how to uninstall<indexterm><primary>RPM</primary><secondary>remove package</secondary></indexterm> a package using <command>rpm</command>:</para>
<screen>
<prompt>[root@jupiter root]#</prompt> <command>rpm -e totem</command>
<prompt>[root@jupiter root]#</prompt>
</screen>
<para>Note that uninstalling is not that verbose by default, it is normal that you don't see much happening.  When in doubt, use <command>rpm <option>-qa</option></command> again to verify that the package has been removed.</para>
<para>RPM can do much more than the couple of basic functions we discussed in this introduction; the <ulink url="http://www.tldp.org/HOWTO/RPM-HOWTO/index.html">RPM HOWTO</ulink> contains further references.</para>
</sect4>
</sect3>
<sect3 id="sect_07_06_02_02"><title>DEB (.deb) packages</title>
<sect4 id="sect_07_06_02_02_01"><title>What are Debian packages?</title>
<para>This package format<indexterm><primary>packages</primary><secondary>DEB</secondary></indexterm> is the default on Debian GNU/Linux, where <command>dselect<indexterm><primary>dselect</primary></indexterm></command>, and, nowadays more common, <command>aptitude<indexterm><primary>aptitude</primary></indexterm></command>, is the standard tool for managing the packages.  It is used to select packages that you want to install or upgrade, but it will also run during the installation of a Debian system and help you to define the access method to use, to list available packages and to configure packages.</para>
<para>The <ulink url="http://debian.org">Debian web site</ulink> contains all information you need, including a <quote>dselect Documentation for Beginners</quote>.</para>
<para>According to the latest news, the Debian package format is becoming more and more popular.  At the time of this writing, 5 of the top-10 distributions use it.  Also <command>apt-get<indexterm><primary>apt-get</primary></indexterm></command> (see <xref linkend="sect_07_06_03_02" /> is becoming extremely popular, also on non-DEB systems.</para>
</sect4>
<sect4 id="sect_07_06_02_02_02"><title>Examples with DEB tools</title>
<para>Checking whether a package is installed is done using the <command>dpkg</command> command.  For instance, if you want to know which version of the <application>Gallery</application> software is installed on your machine:</para>
<screen>
<prompt>nghtwsh@gorefest:~$ </prompt><command>dpkg <option>-l</option> <parameter>*gallery*</parameter></command>
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Installed/Config-files/Unpacked/Failed-config/Half-installed
|/ Err?=(none)/Hold/Reinst-required/X=both-problems (Status,Err: uppercase=bad)
||/ Name           Version        Description
+++-==============-==============-============================================
ii  gallery        1.5-1sarge2    a web-based photo album written in php
</screen>
<para>The <quote>ii</quote> prefix means the package is installed.  Should you see <quote>un</quote> as a prefix, that means that the package is known in the list that your computer keeps, but that it is not installed.</para>
<para>Searching which package a file belongs to is done using the <option>-S</option> to <command>dpkg</command>:</para>
<screen>
<prompt>nghtwsh@gorefest:~$ </prompt><command>dpkg <option>-S</option> <parameter>/bin/cat</parameter></command>
coreutils: /bin/cat
</screen>
<para>More information can be found in the <application>Info</application> pages for <command>dpkg</command>.</para>

</sect4>
</sect3>
<sect3 id="sect_07_06_02_03"><title>Source packages</title>
<para>The largest part of Linux programs is Free/Open Source, so source<indexterm><primary>packages</primary><secondary>source</secondary></indexterm> packages are available for these programs.  Source files are needed for compiling your own program version.  Sources for a program can be downloaded from its web site, often as a compressed tarball (<filename>program-version.tar.gz</filename> or similar). For RPM-based distributions, the source is often provided in the <filename>program-version.src.rpm</filename>.  Debian, and most distributions based on it, provide themselves the adapted source which can be obtained using <command>apt-get <parameter>source</parameter></command>.</para>
<para>Specific requirements, dependencies and installation instructions are provided in the <filename>README</filename> file.  You will probably need a C compiler, <command>gcc</command>.  This GNU C compiler is included in most Linux systems and is ported to many other platforms.</para>
</sect3>
</sect2>
<sect2 id="sect_07_06_03"><title>Automating package management and updates</title>
<sect3 id="sect_07_06_03_01"><title>General remarks</title>
<para>The first thing you do after installing a new system is applying updates;
this applies to all operating systems and Linux is not different.</para>
<para>The updates for most Linux<indexterm><primary>system</primary><secondary>updates</secondary></indexterm> systems can usually be found on a nearby site mirroring your distribution.  Lists of sites offering this service can be found at your distribution's web site, see <xref linkend="app1" />.</para>
<para>Updates<indexterm><primary>packages</primary><secondary>updates</secondary></indexterm> should be applied regularly, daily if possible - but every couple of weeks would be a reasonable start.  You really should try to have the most recent version of your distribution, since Linux changes constantly.  As we said before, new features, improvements and bug fixes are supplied at a steady rhythm, and sometimes important security problems are addressed.</para>
<para>The good news is that most Linux distributions provide tools so that you don't have to upgrade tens of packages daily by hand.  The following sections give an overview of <emphasis>package manager managers.</emphasis>  There is much more to this subject, even regular updates of source packages is manageable automatically; we only list the most commonly known systems.  Always refer to the documentation for your specific distribution for advised procedures.</para>
</sect3>
<sect3 id="sect_07_06_03_02"><title>APT</title>
<para>The <application>Advanced Package Tool</application> is a management<indexterm><primary>packages</primary><secondary>APT</secondary></indexterm> system for software packages.  The command line tool for handling packages is <command>apt-get<indexterm><primary>apt-get</primary></indexterm></command>, which comes with an excellent man page describing how to install and update packages and how to upgrade singular packages or your entire distribution.  APT has its roots in the Debian GNU/Linux distribution, where it is the default manager for the Debian packages.  APT has been ported to work with RPM packages as well.  The main advantage of APT is that it is free and flexible to use.  It will allow you to set up systems similar to the distribution specific (and in some cases commercial) ones listed in the next sections.</para>
<para>Generally, when first using<indexterm><primary>apt-get</primary><secondary>update package list</secondary></indexterm> <command>apt-get</command>, you will need to get an index of the available packages.  This is done using the command</para>
<cmdsynopsis><command>apt-get <parameter>update</parameter></command></cmdsynopsis>
<para>After that<indexterm><primary>apt-get</primary><secondary>upgrade system</secondary></indexterm>, you can use <command>apt-get</command> to upgrade your system:</para>
<cmdsynopsis><command>apt-get <parameter>upgrade</parameter></command></cmdsynopsis>
<para>Do this often, it's an easy way to keep your system up-to-date and thus safe.</para>
<para>Apart from this general usage, <command>apt-get</command> is also very fast for installing<indexterm><primary>apt-get</primary><secondary>installing packages</secondary></indexterm> individual packages.  This is how it works:</para>
<screen>
<prompt>[david@jupiter ~]</prompt> <command>su - -c "apt-get install xsnow"</command>
Password:
Reading Package Lists... Done
Building Dependency Tree... Done
The following NEW packages will be installed:
  xsnow
0 packages upgraded, 1 newly installed, 0 removed and 3 not upgraded.
Need to get 33.6kB of archives.
After unpacking 104kB of additional disk space will be used.
Get:1 http://ayo.freshrpms.net redhat/9/i386/os xsnow 1.42-10 [33.6kB]
Fetched 33.6kB in 0s (106kB/s)
Executing RPM (-Uvh)...
Preparing...                ########################################### [100%]
   1:xsnow                  ########################################### [100%]
</screen>
<para>Note the <option>-c</option> option to the <command>su</command> command, which indicates to the root shell to only execute this command, and then return to the user's environment.  This way, you cannot forget to quit the root account.</para>
<para>If there are any dependencies on other packages, <command>apt-get</command> will download and install these supporting packages.</para>
<para>More information can be found in the <ulink url="http://www.debian.org/doc/user-manuals#apt-howto">APT HOWTO</ulink>.</para>
</sect3>
<sect3 id="sect_07_06_03_03"><title>Systems using RPM packages</title>
<para><application>Update Agent<indexterm><primary>packages</primary><secondary>Update Agent</secondary></indexterm></application>, which originally only supported RedHat RPM packages, is now ported to a wider set of software, including non-RedHat repositories.  This tool provides a complete system for updating the RPM packages on a RedHat or Fedora Core system.  On the command line, type <command>up2date<indexterm><primary>up2date</primary></indexterm></command> to update your system.  On the desktop, by default a small icon is activated, telleng you whether or not there are updates available for your system.</para>
<para><application>Yellowdog's Updater Modified<indexterm><primary>packages</primary><secondary>yum</secondary></indexterm></application> (<command>yum<indexterm><primary>yum</primary></indexterm></command>) is another tool that recently became more popular.  It is an interactive but automated update program for installing, updating or removing RPM packages on a system.  It is the tool of choice on Fedora systems.</para>
<para>On SuSE Linux, everything is done with <application>YaST<indexterm><primary>packages</primary><secondary>YaST</secondary></indexterm></application>, Yet another Setup Tool, which supports a wide variety of system administration tasks, among which updating RPM packages.  Starting from SuSE Linux 7.1 you can also upgrade using a web interface and <application>YOU<indexterm><primary>packages</primary><secondary>YOU</secondary></indexterm></application>, Yast Online Update.</para>
<para>Mandrake Linux and Mandriva provide so-called URPMI<indexterm><primary>packages</primary><secondary>URPMI</secondary></indexterm> tools, a set of wrapper programs that make installing new software easier for the user.  These tools combine with <application>RPMDrake</application> and <application>MandrakeUpdate</application> to provide everything needed for smooth install and uninstall of software packages.  MandrakeOnline offers an extended range of services and can automatically notify administrators when updates are available for your particular Mandrake system.  See <command>man <parameter>urpmi</parameter></command>, among others, for more info.</para>
<para>Also the <application>KDE</application> and <application>Gnome</application> desktop suites have their own (graphical) versions of package managers.</para>
</sect3>

</sect2>

<sect2 id="sect_07_06_04"><title>Upgrading your kernel</title>
<para>Most Linux installations are fine if you periodically upgrade your distribution.  The upgrade<indexterm><primary>kernel</primary><secondary>upgrade</secondary></indexterm> procedure will install a new kernel<indexterm><primary>packages</primary><secondary>kernel</secondary></indexterm> when needed and make all necessary changes to your system.  You should only compile or install a new kernel manually if you need kernel features that are not supported by the default kernel included in your Linux distribution.</para>
<para>Whether compiling your own optimized kernel or using a pre-compiled kernel package, install it in co-existence with the old kernel until you are sure that everything works according to plan.</para>
<para>Then create a dual boot system that will allow you to choose which kernel to boot by updating your boot loader configuration file <filename>grub.conf<indexterm><primary>grub.conf</primary><secondary>example</secondary></indexterm></filename>.  This is a simple example:</para>
<screen>
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making config changes. 
# NOTICE:  You have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /boot/, e.g.
#          root (hd0,0)
#          kernel /vmlinuz-version ro root=/dev/hde8
#          initrd /initrd-version.img
#boot=/dev/hde
default=0
timeout=10
splashimage=(hd0,0)/grub/splash.xpm.gz
title Red Hat Linux new (2.4.9-31)
	root (hd0,0)
	kernel /vmlinuz-2.4.9-31 ro root=/dev/hde8
	initrd /initrd-2.4.9-31.img
title old-kernel
        root (hd0,0)
        kernel /vmlinuz-2.4.9-21 ro root=/dev/hde8
        initrd /initrd-2.4.9-21.img
</screen>
<para>After the new kernel has proven to work, you may remove the lines for the old one from the GRUB config file, although it is best to wait a couple of days just to be sure.</para>
</sect2>
<sect2 id="sect_07_06_05"><title>Installing extra packages from the installation CDs</title>
<sect3 id="sect_07_06_05_01"><title>Mounting a CD</title>
<para>This is basically done in the same way as installing packages manually, except that you have to append the file system of the CD<indexterm><primary>packages</primary><secondary>install from CD</secondary></indexterm> to your machine's file system to make it accessible.  On most systems, this will be done automatically upon insertion of a CD in the drive because the <command>automount<indexterm><primary>automount</primary></indexterm></command> daemon is started up at boot time.  If your CD is not made available automatically, issue the <command>mount<indexterm><primary>mount</primary></indexterm></command> command in a terminal window.  Depending on your actual system configuration, a line similar to this one will usually<indexterm><primary>mount</primary><secondary>mount a CD</secondary></indexterm> do the trick:</para>
<para><cmdsynopsis><command>mount <filename>/dev/cdrom /mnt/cdrom</filename></command></cmdsynopsis></para>
<para>On some systems, only <emphasis>root</emphasis> can mount removable media; this depends on the configuration.</para>
<para>For automation purposes, the CD drive usually has an entry in <filename>/etc/fstab<indexterm><primary>/etc/fstab</primary></indexterm></filename>, which lists the file systems and their mount points, that make up your file system tree.  This is such a line:</para>
<screen>
<prompt>[david@jupiter ~]</prompt> <command>grep cdrom /etc/fstab</command>
/dev/cdrom	/mnt/cdrom	iso9660		noauto,owner,ro 0 0
</screen>
<para>This indicates that the system will understand the command <command>mount <filename>/mnt/cdrom</filename></command>.  The <option>noauto</option> option means that on this system, CDs are not mounted at boot time.</para>
<para>You may even try to right click on the CD icon on your desktop to mount the CD if your file manager doesn't do it for you.  You can check whether it worked issuing the <command>mount<indexterm><primary>mount</primary><secondary>example</secondary></indexterm></command> command with no arguments:</para>
<screen>
<prompt>[david@jupiter ~]</prompt> <command>mount | grep cdrom</command>
/dev/cdrom on /mnt/cdrom type iso9660 (ro,nosuid,nodev)
</screen>
</sect3>
<sect3 id="sect_07_06_05_02"><title>Using the CD</title>
<para>After mounting the CD, you can change directories<indexterm><primary>CD</primary><secondary>using</secondary></indexterm>, usually to the mount point <filename>/mnt/cdrom</filename>, where you can access the content of the CD-ROM.  Use the same commands for dealing with files and directories as you would use for files on the hard disk.</para>
</sect3>
<sect3 id="sect_07_06_05_03"><title>Ejecting the CD</title>
<para>In order to get the CD<indexterm><primary>CD</primary><secondary>eject</secondary></indexterm> out of the drive after you've finished using it, the file system on the CD should be unused.  Even being in one of the subdirectories of the mount point, <filename>/mnt/cdrom</filename> in our example, will be considered as <quote>using the file system</quote>, so you should get out of there.  Do this for instance by typing <command>cd</command> with no arguments, which will put you back in your home directory.  After that, you can either use the command</para>
<cmdsynopsis><command>umount <filename>/mnt/cdrom</filename></command></cmdsynopsis>
<para>or</para>
<cmdsynopsis><command>eject <parameter>cdrom</parameter></command></cmdsynopsis>
<warning><title>Blocked drives</title>
<para><emphasis>NEVER</emphasis> force the drive.  The trick with the paperclip is a bad idea, because this will eventually expunge the CD, but your system will think the CD is still there because normal procedures were not followed.  Chances are likely that you will have to reboot to get the system back in a consistent state.</para>
<para>If you keep getting <quote>device busy</quote> messages, check first that all shell sessions have left the CD file system and that no graphical applications are using it anymore.  When in doubt, use the <command>lsof</command> tool to trace down the process(es) still using the CD resource.</para>  
</warning>
</sect3>
</sect2>

</sect1>
<sect1 id="sect_07_07"><title>Summary</title>
<para>When everything has its place, that means already half the work is done.</para>
<para>While keeping order is important, it is equally important to feel at home in your environment, whether text or graphical.  The text environment is controlled through the shell setup files.  The graphical environment is primarily dependent on the X server configuration, on which a number of other applications are built, such as window and desktop managers and graphical applications, each with their own config files.  You should read the system and program specific documentation to find out about how to configure them.</para>
<para>Regional settings such as keyboard setup, installing appropriate fonts and language support are best done at installation time.</para>
<para>Software is managed either automatically or manually using a package system.</para>
<para>The following commands were introduced in this chapter:</para>
<table frame="all">
<title>New commands in chapter 7: Making yourself at home</title>
<tgroup cols="2" align="left" colsep="1" rowsep="1">
<thead>
<row>
<entry>Command</entry><entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
<entry><command>aptitude</command></entry><entry>Manage packages Debian-style.</entry>
</row>
<row>
<entry><command>automount</command></entry><entry>automatically include newly inserted file systems.</entry>
</row>
<row>
<entry><command>dpkg</command></entry><entry>Debian package manager.</entry>
</row>
<row>
<entry><command>dselect</command></entry><entry>Manage packages Debian-style.</entry>
</row>
<row>
<entry><command>loadkeys</command></entry><entry>Load keyboard configuration.</entry>
</row>

<row>
<entry><command>lsof</command></entry><entry>Identify processes.</entry>
</row>

<row>
<entry><command>mount</command></entry><entry>Include a new file system into the existing file system tree.</entry>
</row>
<row>
<entry><command>ntpdate</command></entry><entry>Set the system time and date using a time server.</entry>
</row>
<row>
<entry><command>quota</command></entry><entry>Display information about allowed disk space usage.</entry>
</row>
<row>
<entry><command>recode</command></entry><entry>Convert files to another character set.</entry>
</row>
<row>
<entry><command>rpm</command></entry><entry>Manage RPM packages.</entry>
</row>
<row>
<entry><command>setfont</command></entry><entry>Choose a font.</entry>
</row>
<row>
<entry><command>timezone</command></entry><entry>Set the timezone.</entry>
</row>
<row>
<entry><command>tzconfig</command></entry><entry>Set the timezone.</entry>
</row>
<row>
<entry><command>ulimit</command></entry><entry>Set or display resource limits.</entry>
</row>
<row>
<entry><command>up2date</command></entry><entry>Manage RPM packages.</entry>
</row>
<row>
<entry><command>urpmi</command></entry><entry>Manage RPM packages.</entry>
</row>
<row>
<entry><command>yum</command></entry><entry>Manage RPM packages.</entry>
</row>
</tbody>
</tgroup>
</table>
</sect1>
<sect1 id="sect_07_08"><title>Exercises</title>
<sect2 id="sect_07_08_01"><title>Shell environment</title>
<itemizedlist>
<listitem><para>Print out your environment settings.  Which variable may be used to store the CPU type of your machine?</para></listitem>
<listitem><para>Make a script that can say something on the lines of <quote>hello, world.</quote>  Give it appropriate permissions so it can be run.  Test your script.</para></listitem>
<listitem><para>Create a directory in your home directory and move the script to the new directory.  Permanently add this new directory to your search path.  Test that the script can be executed without giving a path to its actual location.</para></listitem>
<listitem><para>Create subdirectories in your home directory to store various files, for instance a directory <filename>music</filename> to keep audio files, a directory <filename>documents</filename> for your notes, and so on.  And use them!</para></listitem>
<listitem><para>Create a personalized prompt.</para></listitem>
<listitem><para>Display limits on resource usage.  Can you change them?</para></listitem>
<listitem><para>Try to read compressed man pages without decompressing them first.</para></listitem>
<listitem><para>Make an alias <command>lll</command> which actually executes <command>ls <option>-la</option></command>.</para></listitem>
<listitem><para>Why does the command <command>tail <filename>testfile</filename> &gt; <filename>testfile</filename></command> not work?</para></listitem>
<listitem><para>Mount a data CD, such as your Linux installation CD, and have a look around.  Don't forget to unmount when you don't need it anymore.</para></listitem>
<listitem><para>The script from <xref linkend="sect_07_02_07_02" /> is not perfect.  It generates errors for files that are directories.  Adapt the script so that it only selects plain files for copying.  Use <command>find</command> to make the selection.  Do not forget to make the script executable before you try to run it.</para></listitem>
</itemizedlist>
</sect2>
<sect2 id="sect_07_08_02"><title>Graphical environment</title>

<itemizedlist>
<listitem><para>Try all the mouse buttons in different regions (terminal, background, task bar).</para></listitem>
<listitem><para>Explore the menus.</para></listitem>
<listitem><para>Customize your terminal window.</para></listitem>
<listitem><para>Use the mouse buttons to copy and paste text from one terminal to another.</para></listitem>
<listitem><para>Find out how to configure your window manager; try different workspaces (virtual screens).</para></listitem>
<listitem><para>Add an applet, such as a load monitor, to the task bar.</para></listitem>
<listitem><para>Apply a different theme.</para></listitem>
<listitem><para>Enable the so-called <emphasis>sloppy</emphasis> focus - this is when a window is activated by just moving the mouse over it, so that you do not need to click the window in order to be able to use it.</para></listitem>
<listitem><para>Switch to a different window manager.</para></listitem>
<listitem><para>Log out and select a different session type, like KDE if you were using Gnome before.  Repeat the previous steps.</para></listitem>
</itemizedlist>
</sect2>

</sect1>
</chapter>
