# ADR: CLI Plugin API Implementation

## Status
**Proposed**

## Context
Following the successful modernization of OmegaT's CLI with PicoCLI (ADR-2024001), the current system still lacks plugin integration capabilities. This creates architectural problems where core CLI functionality depends on plugin modules, requiring "reflection hacks" and tight coupling.

### Current State (Post-PicoCLI Migration)
- Modern CLI structure with `org.omegat.cli` package and modular command classes
- Hierarchical command structure (`omegat [COMMAND] [SUB-COMMAND] [OPTIONS] [ARGUMENTS]`)
- Established pattern for command implementation using `@Command` annotations
- Plugin system exists but operates independently of the CLI framework
- **Critical Issue**: ADR-2024001 planned `align` subcommand using reflection to call Aligner plugin module

### Architectural Problem: Aligner Module Case Study
The **Aligner** module exemplifies the current architectural limitation:

- **Module Structure**: Aligner is a bundled subproject with its own entry points
- **Current Integration**:
    - GUI accessible via Tools > Aligner menu (using plugin API + menu API)
    - Has CLI entry point capability but is not integrated with the main CLI
- **ADR-2024001 Workaround**: Planned to implement `align` subcommand in core using reflection to call Aligner module
- **Problem**: Core CLI would depend on the module, violating separation of concerns

### Technical Debt from Current Approach
```java
// ADR-2024001 planned approach (problematic)
@Command(name = "align")
public class AlignCommand implements Callable<Integer> {
    public int call() {
        // parse options and initialize
        int status;
        if (startGUI) {
            status = runGUIAligner();
        } else {
            status = runConsoleAlign();
        }
        return status;
        
    }

    int runGUIAligner() {
         // Reflection hack to call Aligner module
         try {
            ClassLoader cl = PluginUtils.getClassLoader(PluginUtils.PluginType.BASE);
            if (cl == null) {
                return 1;
            }
            Class<?> alignClass = cl.loadClass("org.omegat.gui.align.AlignerModule");
            Method method = alignClass.getMethod("showAligner", String.class);
            method.invoke(null, dir);
            return 0;
        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException
                | InvocationTargetException e) {
            Log.log(e);
            return 1;
        } 
    }
}
```

This approach creates:
- Core CLI dependency on plugin module
- Fragile reflection-based coupling
- Violation of modular architecture principles
- Maintenance burden for a core team

### Business Driver
Resolving architectural debt by enabling plugins to contribute their own CLI commands, eliminating the need for reflection hacks and maintaining proper separation of concerns between core and plugin modules.

## Decision
We will implement a CLI Plugin API that supports two distinct integration patterns: **Command Contribution** (for modules like Aligner) and **Event Hook Integration** (for modules like Scripting), eliminating architectural debt from both reflection hacks and direct dependencies.

### Core Components

#### 1. Plugin Command Registration Interface
Extend `Core` class with plugin registration capabilities:
- `Core.registerCLICommand()` method that accepts PicoCLI `@Command` annotated classes
- Integration with existing `CommandLine` instance for dynamic command registration
- Support for both top-level commands and sub-commands provided by plugins

#### 2. Plugin Event Hook Registration Interface
Extend existing `CoreEvents` class with CLI-specific event capabilities:
- `CoreEvents.registerCLIProjectEventListener()` method for CLI execution event hooks
- `CoreEvents.fireCLIProjectEvent()` method for **synchronous** CLI event firing (no `SwingUtilities.invokeLater()`)
- Leverage existing event infrastructure patterns while addressing console mode constraints
- Support existing project lifecycle events: `LOAD`, `COMPILE`, `SAVE`, `CLOSE`, etc.
- **Key Difference**: CLI events fire synchronously to support console mode execution flow

#### 3. Plugin Command Implementation Pattern (Aligner Use Case)
Plugin modules provide their own command classes:

```java
// In Aligner plugin module
@Command(name = "align", description = "Launch Align Tool")
public class AlignCommand implements Callable<Integer> {
    @Mixin
    private Parameters commonParams;
    
    @Option(names = {"-g", "--gui"}, description = "Launch GUI mode (default)")
    private boolean guiMode = true;
    
    @Override
    public int call() {
        // Direct call to Aligner functionality - no reflection needed
        if (guiMode) {
            AlignMenuPlugin.launchAligner();
        }
        return 0;
    }
}
```

#### 4. Plugin Event Hook Implementation Pattern (Scripting Use Case)
Plugin modules register for CLI execution events using existing `CoreEvents` infrastructure and `PROJECT_CHANGE_TYPE`:

```java
// In Scripting plugin module
public class ScriptingProjectEventListener implements IProjectEventListener {
    @Override
    public void onProjectChangeEvent(IProjectEventListener.PROJECT_CHANGE_TYPE eventType) {
        switch (eventType) {
            case LOAD:
                ScriptingPlugin.executeLoadScript();
                break;
            case COMPILE:
                ScriptingPlugin.executeCompileScript();
                break;
            case SAVE:
                ScriptingPlugin.executeSaveScript();
                break;
            case CLOSE:
                ScriptingPlugin.executeCloseScript();
                break;
        }
    }
}
```

#### 5. CoreEvents Extension Pattern
Extend existing `CoreEvents` class following established patterns but with **synchronous execution** for CLI compatibility:

```java
// In CoreEvents class (following existing pattern but synchronous for CLI)
private static final List<IProjectChangeListener> CLI_EVENT_LISTENERS = new CopyOnWriteArrayList<>();

public static void registerCLIEventListener(final IProjectChangeListener listener) {
    CLI_EVENT_LISTENERS.add(listener);
}

public static void unregisterCLIEventListener(final IProjectChangeListener listener) {
    CLI_EVENT_LISTENERS.remove(listener);
}

// Key difference: Synchronous execution for console mode compatibility
public static void fireCLIEvent(final IProjectEventListener.PROJECT_CHANGE_TYPE eventType) {
    // No SwingUtilities.invokeLater() - execute synchronously in console mode
    Log.logInfoRB("LOG_INFO_EVENT_CLI", eventType);
    for (IProjectChangeListener listener : CLI_EVENT_LISTENERS) {
        try {
            listener.onProjectChange(eventType);
        } catch (Throwable t) {
            log("ERROR_EVENT_CLI", t);
        }
    }
}
```

#### 6. Console Mode Constraint Resolution
The current `executeConsoleScript()` implementation reveals a critical constraint:

```java
/**
 * Execute a script as PROJECT_CHANGE events. We can't use the regular
 * project listener because the SwingUtilities.invokeLater method used in
 * CoreEvents doesn't stop the project processing in console mode.
 */
```

**Solution**: CLI events must execute synchronously to maintain proper execution flow in console mode, unlike GUI events which use `SwingUtilities.invokeLater()`.
```

#### 7. Dual Plugin Module Integration
Plugins register during initialization using appropriate pattern:

```java
// Aligner plugin: Command contribution
public class AlignerPlugin implements IPlugin {
    @Override
    public void loadPlugin() {
        Core.registerCLICommand(AlignCommand.class);
        Core.registerMenuHandler(...); // Existing menu continues to work
    }
}

// Scripting plugin: Event hook integration using existing CoreEvents (synchronous CLI events)
public class ScriptingPlugin implements IPlugin {
    @Override
    public void loadPlugin() {
        CoreEvents.registerCLIEventListener(new ScriptingCLIEventListener());
    }
}
```

### Implementation Approach
1. **Remove Direct Dependencies**: Eliminate both reflection hack (Aligner) and direct method calls (Scripting) from core CLI
2. **Plugin Registration Extensions**: Extend Core class for command registration, extend CoreEvents for **synchronous** event hook registration
3. **Leverage Existing Infrastructure**: Use established `CoreEvents` patterns but with console mode compatibility
4. **Synchronous Event Architecture**: Replace direct scripting calls with `CoreEvents.fireCLIEvent()` calls that execute synchronously
5. **Modular Commands**: Enable plugins to provide self-contained command implementations
6. **Maintain Separation**: Keep the core CLI framework independent of both types of plugin implementations
7. **Console Mode Compatibility**: Ensure CLI events don't break console execution flow like GUI events would

### Before/After Architecture Comparison

**Before (Current/ADR-2024001 planned approach)**:
```java
// Core CLI with architectural problems
@Command(name = "align")
public class AlignCommand {
    // Fragile reflection to plugin module
}

private static int runConsoleTranslate() {
    // ... project operations ...
    executeConsoleScript(COMPILE); // Direct dependency on scripting
}
```

**Current (Direct dependency with console-mode specific logic)**:
```java
// Main.runConsoleTranslate() - direct coupling
private static void executeConsoleScript(PROJECT_CHANGE_TYPE eventType) {
    // Custom console logic - can't use CoreEvents due to SwingUtilities.invokeLater()
    if (PARAMS.containsKey(CLIParameters.SCRIPT)) {
        // Direct script execution logic
        ScriptRunner.executeScript(script, binding);
    }
}
```

**After (Plugin API approach leveraging CoreEvents with synchronous CLI events)**:
```java
// Core CLI: Clean, no plugin dependencies, synchronous CLI events
private static int runConsoleTranslate() {
    // ... project operations ...
    CoreEvents.fireCLIEvent(IProjectEventListener.PROJECT_CHANGE_TYPE.COMPILE); // Synchronous, console-compatible
}

// Aligner Plugin: Self-contained command
@Command(name = "align") 
public class AlignCommand { /* Direct access */ }

// Scripting Plugin: Event-driven hooks using synchronous CLI events
public class ScriptingCLIEventListener implements IProjectChangeListener {
    public void onProjectChangeEvent(IProjectEventListener.PROJECT_CHANGE_TYPE eventType) {
        // Same logic as current executeConsoleScript() but in plugin
        if (hasScript()) {
            ScriptRunner.executeScript(script, binding);
        }
    }
}
```

### Command Structure Integration
Plugin contributions integrate seamlessly into the existing hierarchy:

```
OmegaT [CORE-COMMAND|PLUGIN-COMMAND] [SUB-COMMAND] [OPTIONS] [ARGUMENTS]
```

**Core Commands** (from ADR-2024001):
- `start`, `team`, `stats`, `translate`, `pseudo`

**Plugin Commands** (contributed by modules):
- `align` - Provided by Aligner plugin module

**Event-Driven Integration** (invisible to users):
- `translate` command triggers events that Scripting plugin can hook into
- Clean separation between command execution and plugin responses

### Help System Integration
Plugin commands appear naturally in `help` output:
```bash
$ omegat --help
Commands:
  start      Start OmegaT GUI.
  align      Launch Align Tool.           # ← Provided by Aligner plugin
  translate  Console translate command.   # ← Triggers events for Scripting plugin
  stats      Show translation statistics.
  team       Team admin utility.
```

## Consequences

### Positive
- **Leverages Existing Infrastructure**: Builds upon proven `CoreEvents` architecture and patterns
- **Reuses Existing Enums**: Uses established `PROJECT_CHANGE_TYPE` instead of creating new CLI-specific types
- **Console Mode Compatible**: Synchronous CLI events avoid `SwingUtilities.invokeLater()` issues in console mode
- **Unified Event Model**: CLI events and regular project events use the same type system
- **Resolves Dual Architectural Debt**: Eliminates both reflection hack (Aligner) and direct dependency (Scripting) problems
- **Proper Separation of Concerns**: Core CLI remains independent of both command and event plugin implementations
- **Maintains Console Execution Flow**: CLI events execute synchronously, preventing console mode blocking issues
- **Flexible Integration Patterns**: Supports both command contribution and event-driven integration as needed
- **Established Error Handling**: CLI events inherit robust error handling and logging patterns from `CoreEvents`
- **Thread Compatibility**: CLI events respect console mode execution requirements
- **Simplified Plugin Development**: Plugin developers already familiar with `PROJECT_CHANGE_TYPE` can easily adopt CLI events
- **Modular Ownership**: Plugin teams maintain their own CLI functionality and event handlers
- **Scalable Framework**: Supports multiple plugin modules with different integration needs
- **Real-World Validation**: Solves actual problems with existing Aligner and Scripting modules

### Negative
- **Synchronous vs Asynchronous Event Model**: CLI events behave differently from GUI events (synchronous vs `SwingUtilities.invokeLater()`)
- **Plugin Dependencies**: Plugins must include PicoCLI patterns and understand different event execution models
- **Console Mode Complexity**: Different execution patterns for CLI vs GUI contexts add complexity
- **Event Timing**: Synchronous event-driven hooks depend on proper timing in the CLI execution flow
- **Command Conflicts**: Potential naming conflicts between plugin command contributions
- **Documentation Coordination**: Multiple integration patterns and execution contexts require comprehensive documentation

### Neutral
- **Learning Curve**: Plugin developers need to understand new API patterns
- **Documentation Requirements**: Comprehensive documentation needed for plugin developers

## Known Limitations
The initial implementation will **not** support:
- Runtime command/event listener unregistration (plugins remain registered for application lifecycle)
- Command priority/ordering control between plugin modules
- Complex inter-plugin dependencies for commands or events
- Plugin namespace isolation (requiring careful naming coordination for commands)
- Event handler priority/ordering control when multiple plugins listen to same events

**Note**: These limitations are acceptable for the Aligner and Scripting use cases and most anticipated plugin scenarios. Future enhancements can address advanced use cases as they emerge.

## Alternatives Considered

### Alternative 1: Keep Current Approaches (Reflection + Direct Calls)
Maintain ADR-2024001 planned reflection for Aligner and current direct scripting calls
- **Rejected**: Perpetuates architectural debt, tight coupling, and fragile dependencies

### Alternative 2: Single Integration Pattern
Implement only command contribution OR only event hooks, not both
- **Rejected**: Doesn't address the full scope of architectural problems (need both patterns)

### Alternative 3: Plugin-Specific CLI Entry Points
Each plugin provides separate CLI executable (e.g., `omegat-align`, `omegat-script`)
- **Rejected**: Fragments user experience and complicates discovery and documentation

### Alternative 4: Configuration-Based Integration
Use configuration files to define both plugin commands and event bindings
- **Rejected**: More complex than the annotation-based approach and inconsistent with PicoCLI patterns

## Implementation Notes

### Success Criteria
- [ ] `Core.registerCLICommand()` method implemented for dynamic PicoCLI command registration
- [ ] `CoreEvents.registerCLIProjectChangeListener()` and `CoreEvents.fireCLIProjectChangeEvent()` methods implemented following existing patterns
- [ ] **Aligner module successfully registers `align` command** (command contribution validation)
- [ ] **Scripting module successfully hooks into `translate` command events** (event integration validation)
- [ ] **Core CLI no longer contains reflection-based `align` implementation**
- [ ] **Core CLI `translate` command uses `CoreEvents.fireCLIProjectChangeEvent(PROJECT_CHANGE_TYPE.COMPILE)` instead of direct scripting calls**
- [ ] CLI events follow same error handling and logging patterns as existing `CoreEvents`
- [ ] `omegat --help` lists `align` command when Aligner plugin is loaded
- [ ] `omegat align --help` displays Aligner-specific help content
- [ ] Console translate execution triggers proper `CoreEvents.fireCLIProjectChangeEvent(PROJECT_CHANGE_TYPE.*)` sequence for scripting hooks
- [ ] Plugin commands can use existing `Parameters` mixin for common options
- [ ] Backward compatibility maintained with existing core commands from ADR-2024001
- [ ] Plugin developer documentation covers both command and event integration patterns
- [ ] Integration tests validate both Aligner command and Scripting event scenarios

### Implementation Dependencies
- **PicoCLI Infrastructure**: Builds upon existing PicoCLI integration from ADR-2024001
- **CoreEvents Infrastructure**: Extends an existing event system with CLI-specific events
- **Plugin Loading System**: Integration with existing plugin initialization lifecycle
- **Aligner Module**: Coordinate with Aligner team for command implementation
- **Scripting Module**: Coordinate with Scripting team for event listener implementation
- **Console Translation Flow**: Modify existing `runConsoleTranslate()` method to use `CoreEvents.fireCLIProjectChangeEvent(PROJECT_CHANGE_TYPE.*)`
- **Core Architecture**: Extend Core class with command registration, extend CoreEvents with CLI event support using existing enums

### Risks and Mitigations
- **Risk**: Synchronous CLI events could block console execution if plugin event handlers are slow
    - **Mitigation**: Implement timeout mechanisms and provide guidelines for fast event handler implementation
- **Risk**: Event execution model differences between CLI and GUI contexts confuse plugin developers
    - **Mitigation**: Clear documentation explaining synchronous CLI events vs asynchronous GUI events, provide examples
- **Risk**: Scripting event hooks break the console translation flow
    - **Mitigation**: Implement robust error handling and fallback behavior for event failures, maintain synchronous execution
- **Risk**: Console mode compatibility issues with event system integration
    - **Mitigation**: Thorough testing in console mode, ensure no `SwingUtilities.invokeLater()` usage in CLI event path

## Related Documents
- Plugin System Architecture Documentation
- CLI Command Reference
- Core API Specifications

## Contributors
- **Proposer**: Hiroshi Miura
- **Reviewer**: Jean-Christophe Helary

---
*This ADR will be updated as implementation progresses and additional requirements are identified.*