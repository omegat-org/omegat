# ADR: Refactoring Entry Info Panes Threading Model

## Status
**Proposed**

## Context

### Current Architecture Overview

The OmegaT application uses a common pattern across multiple core UI components for displaying contextual information about the currently active translation entry. This pattern is implemented through the `EntryInfoThreadPane<T>` abstract base class, which is extended by five critical components:

1. **`MachineTranslateTextArea`** - Displays machine translation suggestions
2. **`MatchesTextArea`** - Shows translation memory matches
3. **`GlossaryTextArea`** - Displays glossary entries
4. **`DictionaryTextArea`** - Shows dictionary definitions
5. **`MultipleTransPane`** - Displays alternative translations

These components form the **core information panel system** of OmegaT's main window, providing translators with essential context for their work.

### The EntryInfoThreadPane Pattern

```java
public abstract class EntryInfoThreadPane<T> extends EntryInfoPane<T> 
        implements IEntryEventListener {
    
    protected volatile SourceTextEntry currentlyProcessedEntry;
    
    public void onEntryActivated(SourceTextEntry newEntry) {
        currentlyProcessedEntry = newEntry;
        startSearchThread(newEntry);
    }
    
    protected abstract void startSearchThread(SourceTextEntry newEntry);
    protected abstract void setFoundResult(SourceTextEntry processedEntry, T data);
}
```


**Design Intent**: Provide a reusable framework for asynchronously fetching and displaying entry-related information.

**Implementation Pattern**: Each subclass implements `startSearchThread()` by creating one or more `EntryInfoSearchThread<T>` instances that:
1. Perform background searches/queries
2. Call back to `setFoundResult()` on the UI thread
3. Update the pane's display

### Systemic Architecture Problems

This pattern, while conceptually sound, has fundamental design flaws that affect **all five core components**:

#### 1. **Violation of Single Responsibility Principle**

The same class is responsible for:
- **View Rendering**: Extends `JEditorPane`, manages HTML display, highlighting, scrolling
- **Thread Management**: Creates, starts, and (attempts to) manage background threads
- **Business Logic**: Decides when to search, what to cache, how to filter results
- **Event Handling**: Listens to entry activation events
- **State Management**: Tracks current entry and displayed results

This violates the fundamental principle that a class should have one reason to change.

#### 2. **Unmanaged Thread Lifecycle**

```java
// Common pattern across all five implementations
protected void startSearchThread(SourceTextEntry newEntry) {
    for (SomeProvider provider : getProviders()) {
        new SearchThread(provider, newEntry).start();  // Fire and forget!
    }
}
```


**Critical Issues:**
- Threads are created but never explicitly stopped
- No mechanism to cancel in-flight requests
- Each entry activation creates new threads without cleaning up previous ones
- Thread references are lost immediately after `.start()`
- No way to wait for completion (essential for testing)
- Accumulated threads over application lifetime

**Real-World Impact:**
```
Entry 1 activation → Creates 3 threads (MT1, MT2, MT3)
Entry 2 activation → Creates 3 MORE threads (MT1, MT2, MT3)
Entry 3 activation → Creates 3 MORE threads (MT1, MT2, MT3)
...
After 100 entries → 300+ threads created (many still running)
```


#### 3. **Testing Nightmare**

The test failure pattern is systematic across all panes:

```java
// From MachineTranslateTest.java
@Test
public void testMachineTranslation() throws Exception {
    openSampleProject(PROJECT_PATH);
    robot().waitForIdle();  // Only waits for EDT, not background threads!
    
    MachineTranslateTextArea pane = TestCoreState.getInstance().getMachineTranslatePane();
    assertEquals(DummyMachineTranslator.ENGINE_NAME, 
                 pane.getDisplayedTranslation().translatorName);
}
```


**Problems Affecting All Panes:**

1. **Race Conditions**: `robot().waitForIdle()` only waits for Swing EDT, not the `EntryInfoSearchThread` instances
2. **Nondeterministic Results**: Tests pass or fail randomly depending on thread scheduling
3. **State Pollution**: Threads from previous tests continue running and update UI
4. **No Clean Shutdown**: `TestCoreGUI.cleanupGUIComponents()` cannot stop background threads
5. **Duplicate Results**: Multiple test runs accumulate results from lingering threads

```java
// Current cleanup - only handles UI, not threads!
private void cleanupGUIComponents() {
    if (window != null) {
        window.cleanUp();  // Does NOT stop EntryInfoSearchThread instances!
    }
    if (mainWindow != null) {
        mainWindow.getApplicationFrame().setVisible(false);
        // Background threads still running here!
    }
}
```


#### 4. **Race Conditions in Production**

**Scenario**: User rapidly navigates through entries
```
T=0ms:   Activate Entry A → Start threads A1, A2, A3
T=50ms:  Activate Entry B → Start threads B1, B2, B3 (A1, A2, A3 still running!)
T=100ms: Activate Entry C → Start threads C1, C2, C3 (all previous threads still running!)
T=150ms: Thread A1 completes → Updates UI with Entry A data (wrong entry!)
T=200ms: Thread B2 completes → Updates UI with Entry B data (wrong entry!)
T=250ms: Thread C3 completes → Updates UI with Entry C data (correct, but delayed)
```


**Result**: User sees flickering, stale data, or wrong entry information.

#### 5. **Concurrency Workarounds Instead of Solutions**

All implementations use defensive coding to handle threading problems:

```java
// From MachineTranslateTextArea
protected List<MachineTranslationInfo> displayed = new CopyOnWriteArrayList<>();

// From GlossaryTextArea
private final List<GlossaryEntry> entries = new CopyOnWriteArrayList<>();

// Pattern repeated across all panes
```


**Why This Is Wrong:**
- `CopyOnWriteArrayList` treats symptoms (concurrent modification) not cause (uncontrolled threading)
- Performance overhead on every update
- Complexity without solving underlying race conditions
- False sense of thread safety

#### 6. **Tight Coupling to Base Class Design**

All five components are **forced** to implement threading because they extend `EntryInfoThreadPane`:

```java
public class MatchesTextArea extends EntryInfoThreadPane<List<NearEntry>> {
    // MUST implement this, even if threading isn't the best choice
    protected void startSearchThread(SourceTextEntry newEntry) {
        // Forced into this pattern
    }
}
```


**Consequences:**
- Cannot use different concurrency strategies per component
- Cannot easily add features like cancellation, timeouts, retry
- Difficult to optimize per-component (e.g., glossary might want caching, MT might want throttling)
- Testing requires mocking the entire inheritance chain

### Impact Analysis by Component

| Component | Providers per Entry | Thread Creation Rate | Business Logic Complexity | Test Reliability Issue |
|-----------|---------------------|----------------------|---------------------------|------------------------|
| **MachineTranslateTextArea** | 1-10 MT engines | High (multiple per entry) | High (caching, preferences) | **Severe** - Multiple async results |
| **MatchesTextArea** | 1 TM search | Medium | High (fuzzy matching, scoring) | **Moderate** - Single async result |
| **GlossaryTextArea** | 1 glossary manager | Medium | Medium (term matching) | **Moderate** - Incremental updates |
| **DictionaryTextArea** | 1-5 dictionaries | Medium-High | Medium (multiple sources) | **Moderate** - Multiple async results |
| **MultipleTransPane** | 1 project scan | Low | Medium (statistics) | **Low** - Infrequent activation |

### Why This Is a Core Architecture Issue

This isn't just a threading problem—it's a **fundamental architectural debt** that affects:

1. **Application Stability**: Thread leaks, race conditions, resource exhaustion
2. **User Experience**: Stale data, flickering updates, perceived slowness
3. **Development Velocity**: Every new feature must navigate threading complexity
4. **Test Reliability**: Cannot achieve deterministic testing of core features
5. **Code Quality**: Workarounds accumulate, original intent obscured
6. **Maintenance Cost**: Five components with similar but slightly different threading logic

### Root Cause Analysis

The root cause is **mixing concerns in the inheritance hierarchy**:

```
JEditorPane (Swing UI)
    ↓
EntryInfoPane<T> (Display logic)
    ↓
EntryInfoThreadPane<T> (Threading + Event listening + Display)
    ↓
[Five concrete implementations]
```


**The flaw**: Threading is orthogonal to display responsibility, but the inheritance forces them together.

### Current Workaround Evidence

Developers are aware of the problem, as evidenced by:

```java
// From test infrastructure
protected void openSampleProjectWaitMatches(Path projectPath) throws Exception {
    MatchesTextArea matchesTextArea = (MatchesTextArea) Core.getMatcher();
    CountDownLatch latch = new CountDownLatch(1);
    matchesTextArea.addPropertyChangeListener("matches", evt -> {
        SwingUtilities.invokeLater(() -> {
            if (matchesTextArea.getActiveMatch() != null) {
                latch.countDown();
            }
        });
    });
    openSampleProject(projectPath);
    assertTrue("Active match not set", latch.await(timeout, TimeUnit.SECONDS));
}
```


Similar patterns exist for:
- `openSampleProjectWaitGlossary()`
- `openSampleProjectWaitDictionary()`
- `openSampleProjectWaitPropertyPane()`

**Why This Is Wrong:**
- Tests shouldn't need custom waiting logic for each pane
- Property listeners are workarounds for lack of proper async API
- Timeout-based testing is fragile and slow

## Decision

We will refactor **all five entry info panes** to use a **Service-Controller-View** architecture with managed concurrency. This is a comprehensive architectural change affecting the core of the application.

### New Architecture Pattern

```
┌────────────────────────────────────────────────────────────┐
│                      CoreEvents                            │
│               (Entry Lifecycle Events)                     │
└───────────────────────┬────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        │               │               │
        ↓               ↓               ↓
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│   MT         │ │   Matches    │ │  Glossary    │  ... (5 Controllers)
│  Controller  │ │  Controller  │ │  Controller  │
└──┬────────┬──┘ └──┬────────┬──┘ └──┬────────┬──┘
   │        │       │        │       │        │
   │Service │View   │Service │View   │Service │View
   ↓        ↓       ↓        ↓       ↓        ↓
┌────────┐ ┌────┐ ┌────────┐ ┌────┐ ┌────────┐ ┌────┐
│MT      │ │MT  │ │Matches │ │Match│ │Glossary│ │Glos│
│Service │ │Area│ │Service │ │Area │ │Service │ │Area│
└────────┘ └────┘ └────────┘ └────┘ └────────┘ └────┘
```


### Universal Service Layer Interface

```java
/**
 * Common interface for all entry info services.
 * Each service encapsulates business logic and threading.
 */
public interface EntryInfoService<T> {
    /**
     * Fetch information for an entry asynchronously.
     * @return CompletableFuture that completes with results
     */
    CompletableFuture<T> fetchInfo(SourceTextEntry entry, FetchContext context);
    
    /**
     * Shutdown service and cleanup resources.
     * Must wait for in-flight requests to complete or timeout.
     */
    void shutdown();
    
    /**
     * Check if service is operational.
     */
    boolean isAvailable();
}

/**
 * Context for fetch operations - provides common data needed by services
 */
public class FetchContext {
    private final Language sourceLanguage;
    private final Language targetLanguage;
    private final boolean forceRefresh;
    private final Map<String, Object> additionalParams;
    
    // Constructor, getters...
}
```


### Universal Controller Pattern

```java
/**
 * Base controller for all entry info panes.
 * Handles common concerns: cancellation, error handling, UI updates.
 */
public abstract class EntryInfoController<T> implements IEntryEventListener {
    
    protected final EntryInfoService<T> service;
    protected final EntryInfoView<T> view;
    protected CompletableFuture<T> currentRequest;
    
    public EntryInfoController(EntryInfoService<T> service, EntryInfoView<T> view) {
        this.service = service;
        this.view = view;
        CoreEvents.registerEntryEventListener(this);
    }
    
    @Override
    public void onEntryActivated(SourceTextEntry newEntry) {
        cancelCurrentRequest();
        
        if (!service.isAvailable()) {
            view.clear();
            return;
        }
        
        view.showLoading();
        
        FetchContext context = createFetchContext(newEntry);
        currentRequest = service.fetchInfo(newEntry, context);
        
        currentRequest
            .thenAcceptAsync(this::handleResult, SwingUtilities::invokeLater)
            .exceptionally(this::handleError);
    }
    
    protected abstract FetchContext createFetchContext(SourceTextEntry entry);
    
    private void handleResult(T result) {
        view.displayResult(result);
    }
    
    private Void handleError(Throwable ex) {
        Log.log(ex);
        view.showError(ex.getMessage());
        return null;
    }
    
    protected void cancelCurrentRequest() {
        if (currentRequest != null && !currentRequest.isDone()) {
            currentRequest.cancel(true);
        }
    }
    
    @Override
    public void onProjectChanged(PROJECT_CHANGE_TYPE eventType) {
        switch (eventType) {
            case CLOSE:
                cancelCurrentRequest();
                view.clear();
                break;
            // ... other cases
        }
    }
    
    public void dispose() {
        cancelCurrentRequest();
        CoreEvents.unregisterEntryEventListener(this);
        service.shutdown();
    }
}
```


### Universal View Interface

```java
/**
 * Common interface for all entry info views.
 * Pure UI responsibility - no threading, no business logic.
 */
public interface EntryInfoView<T> {
    void displayResult(T result);
    void showLoading();
    void showError(String message);
    void clear();
}
```


## Implementation Plan

### Phase 0: Foundation (Week 1-2)

**Goal**: Create common infrastructure without breaking existing code

1. **Create Core Interfaces**
```java
org.omegat.gui.common.service.EntryInfoService<T>
   org.omegat.gui.common.service.FetchContext
   org.omegat.gui.common.controller.EntryInfoController<T>
   org.omegat.gui.common.view.EntryInfoView<T>
```


2. **Create Managed Executor Infrastructure**
```java
public class EntryInfoExecutorManager {
       private static final ExecutorService sharedExecutor = 
           Executors.newCachedThreadPool(new NamedThreadFactory("EntryInfo"));
       
       public static ExecutorService getExecutor() {
           return sharedExecutor;
       }
       
       public static void shutdown() {
           sharedExecutor.shutdown();
           try {
               if (!sharedExecutor.awaitTermination(10, TimeUnit.SECONDS)) {
                   sharedExecutor.shutdownNow();
               }
           } catch (InterruptedException e) {
               sharedExecutor.shutdownNow();
               Thread.currentThread().interrupt();
           }
       }
   }
```


3. **Create Test Infrastructure**
```java
public class EntryInfoTestSupport {
       /**
        * Wait for CompletableFuture-based pane to complete updates
        */
       public static <T> T awaitResult(CompletableFuture<T> future, int timeout) 
               throws Exception {
           return future.get(timeout, TimeUnit.SECONDS);
       }
       
       /**
        * Ensure all entry info services are idle
        */
       public static void awaitAllPanesIdle() throws Exception {
           // Wait for all CompletableFutures to complete
       }
   }
```


**Deliverables:**
- Core interfaces defined
- Shared executor infrastructure
- Test support utilities
- Documentation of new patterns

**Testing**: Compile-time only (no runtime changes yet)

---

### Phase 1: Machine Translation (Week 3-4)

**Goal**: Refactor most complex pane as reference implementation

**Why MT First**: 
- Multiple providers (most complex case)
- Clear caching/preference logic
- Existing test case to validate
- Other panes can follow same pattern

#### 1.1: Service Layer

```java
public class MachineTranslationService implements EntryInfoService<List<MachineTranslationInfo>> {
    private final List<IMachineTranslation> translators;
    private final ExecutorService executor;
    
    public MachineTranslationService(List<IMachineTranslation> translators) {
        this.translators = translators;
        this.executor = EntryInfoExecutorManager.getExecutor();
    }
    
    @Override
    public CompletableFuture<List<MachineTranslationInfo>> fetchInfo(
            SourceTextEntry entry, FetchContext context) {
        
        String sourceText = entry.getSrcText();
        boolean force = context.isForceRefresh();
        
        List<CompletableFuture<MachineTranslationInfo>> futures = translators.stream()
            .filter(IMachineTranslation::isEnabled)
            .map(mt -> CompletableFuture.supplyAsync(() -> 
                fetchSingleTranslation(mt, sourceText, context, force, entry), executor))
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .filter(Objects::nonNull)
                .sorted(Comparator.comparing(info -> info.translatorName))
                .collect(Collectors.toList()));
    }
    
    private MachineTranslationInfo fetchSingleTranslation(
            IMachineTranslation translator, String text, 
            FetchContext context, boolean force, SourceTextEntry entry) {
        try {
            Language source = context.getSourceLanguage();
            Language target = context.getTargetLanguage();
            
            // Business logic: caching, preferences
            if (!force) {
                String cached = translator.getCachedTranslation(source, target, text);
                if (cached != null || shouldSkipAutoFetch(entry)) {
                    return cached != null ? 
                        new MachineTranslationInfo(translator.getName(), cached) : null;
                }
            }
            
            String result = translator.getTranslation(source, target, text);
            return result != null ? 
                new MachineTranslationInfo(translator.getName(), result) : null;
                
        } catch (Exception e) {
            Log.log(e);
            return null;
        }
    }
    
    private boolean shouldSkipAutoFetch(SourceTextEntry entry) {
        return !Preferences.isPreferenceDefault(Preferences.MT_AUTO_FETCH, false)
            || (Preferences.isPreference(Preferences.MT_ONLY_UNTRANSLATED)
                && Core.getProject().getTranslationInfo(entry).isTranslated());
    }
    
    @Override
    public void shutdown() {
        // Shared executor managed by EntryInfoExecutorManager
    }
    
    @Override
    public boolean isAvailable() {
        return translators.stream().anyMatch(IMachineTranslation::isEnabled);
    }
}
```


#### 1.2: Controller

```java
public class MachineTranslationController extends EntryInfoController<List<MachineTranslationInfo>> {
    
    public MachineTranslationController(
            MachineTranslationService service, 
            MachineTranslateTextArea view) {
        super(service, view);
    }
    
    @Override
    protected FetchContext createFetchContext(SourceTextEntry entry) {
        ProjectProperties pp = Core.getProject().getProjectProperties();
        return new FetchContext.Builder()
            .sourceLanguage(pp.getSourceLanguage())
            .targetLanguage(pp.getTargetLanguage())
            .forceRefresh(false)
            .additionalParam("glossary", getGlossaryMap(entry))
            .build();
    }
    
    private Map<String, String> getGlossaryMap(SourceTextEntry entry) {
        return Core.getGlossaryManager().searchSourceMatches(entry).stream()
            .collect(Collectors.toMap(GlossaryEntry::getSrcText, GlossaryEntry::getLocText));
    }
    
    public void forceRefresh() {
        SourceTextEntry entry = getCurrentEntry();
        if (entry != null) {
            FetchContext context = createFetchContext(entry);
            context.setForceRefresh(true);
            cancelCurrentRequest();
            
            currentRequest = ((MachineTranslationService) service).fetchInfo(entry, context);
            currentRequest.thenAcceptAsync(
                result -> ((MachineTranslateTextArea) view).displayResult(result),
                SwingUtilities::invokeLater);
        }
    }
}
```


#### 1.3: View Refactoring

```java
/**
 * Pure view component - NO threading logic
 */
@SuppressWarnings("serial")
public class MachineTranslateTextArea extends JEditorPane 
        implements EntryInfoView<List<MachineTranslationInfo>>, IPaneMenu {
    
    // Removed: extends EntryInfoThreadPane
    // Removed: startSearchThread(), FindThread inner class
    // Removed: CopyOnWriteArrayList (no longer needed)
    
    private List<MachineTranslationInfo> displayed = new ArrayList<>();
    private int selectedIndex = -1;
    private final DockableScrollPane scrollPane;
    
    public MachineTranslateTextArea(IMainWindow mw) {
        super();
        setContentType("text/html");
        setEditable(false);
        StaticUIUtils.makeCaretAlwaysVisible(this);
        initDocument();
        
        this.setText(EXPLANATION);
        setMinimumSize(new Dimension(100, 50));
        
        String title = OStrings.getString("GUI_MATCHWINDOW_SUBWINDOWTITLE_MachineTranslate");
        scrollPane = new DockableScrollPane("MACHINE_TRANSLATE", title, this, true);
        mw.addDockable(scrollPane);
    }
    
    @Override
    public void displayResult(List<MachineTranslationInfo> translations) {
        UIThreadsUtil.mustBeSwingThread();
        
        this.displayed.clear();
        this.displayed.addAll(translations);
        this.selectedIndex = -1;
        
        if (translations.isEmpty()) {
            setText(EXPLANATION);
            return;
        }
        
        StringBuilder sb = new StringBuilder("<html>");
        for (int i = 0; i < displayed.size(); i++) {
            MachineTranslationInfo info = displayed.get(i);
            sb.append("<div id=\"").append(i).append("\">");
            sb.append(info.result);
            sb.append("<div class=\"engine\">&lt;");
            sb.append(info.translatorName);
            sb.append("&gt;</div></div>");
        }
        sb.append("</html>");
        setText(sb.toString());
    }
    
    @Override
    public void showLoading() {
        UIThreadsUtil.mustBeSwingThread();
        // Optional: show loading indicator
    }
    
    @Override
    public void showError(String message) {
        UIThreadsUtil.mustBeSwingThread();
        setText("<html><body style='color:red;'>" + message + "</body></html>");
    }
    
    @Override
    public void clear() {
        getHighlighter().removeAllHighlights();
        displayed.clear();
        selectedIndex = -1;
        setText(EXPLANATION);
    }
    
    // Existing display methods remain: getDisplayedTranslation(), highlightSelected(), etc.
}
```


#### 1.4: Integration & Wiring

```java
// In TestMainWindow or application initialization
public class MainWindow {
    
    private MachineTranslationController mtController;
    
    private void initializeMachineTrans lation() {
        // Create translators
        List<IMachineTranslation> translators = new ArrayList<>();
        for (Class<?> mtc : PluginUtils.getMachineTranslationClasses()) {
            try {
                IMachineTranslation mt = (IMachineTranslation) 
                    mtc.getDeclaredConstructor().newInstance();
                translators.add(mt);
            } catch (Exception ex) {
                Log.log(ex);
            }
        }
        
        // Create service
        MachineTranslationService service = new MachineTranslationService(translators);
        
        // Create view
        MachineTranslateTextArea view = new MachineTranslateTextArea(this);
        
        // Create controller (automatically registers as event listener)
        mtController = new MachineTranslationController(service, view);
        
        // Store references
        Core.setMachineTranslatePane(view);
    }
    
    public void dispose() {
        if (mtController != null) {
            mtController.dispose();
        }
        // ... other cleanup
    }
}
```


#### 1.5: Test Updates

```java
public class MachineTranslateTest extends TestCoreGUI {
    
    private static final Path PROJECT_PATH = Paths.get("test-acceptance/data/project/");
    
    @Test
    public void testMachineTranslation() throws Exception {
        // Load project
        openSampleProject(PROJECT_PATH);
        
        // Get controller (stored during initialization)
        MachineTranslationController controller = 
            TestCoreState.getInstance().getMachineTranslationController();
        
        // Wait for async operation to complete
        CompletableFuture<List<MachineTranslationInfo>> future = controller.getCurrentRequest();
        List<MachineTranslationInfo> results = future.get(timeout, TimeUnit.SECONDS);
        
        // Verify results
        assertFalse("Should have MT results", results.isEmpty());
        MachineTranslationInfo first = results.get(0);
        assertEquals(DummyMachineTranslator.ENGINE_NAME, first.translatorName);
        assertEquals(DummyMachineTranslator.TRANSLATION, first.result);
        
        // Verify UI updated
        MachineTranslateTextArea view = TestCoreState.getInstance().getMachineTranslatePane();
        assertEquals(first.translatorName, view.getDisplayedTranslation().translatorName);
    }
    
    @Test
    public void testForceRefresh() throws Exception {
        openSampleProject(PROJECT_PATH);
        
        MachineTranslationController controller = 
            TestCoreState.getInstance().getMachineTranslationController();
        
        // Force refresh
        controller.forceRefresh();
        
        // Wait for new request
        CompletableFuture<List<MachineTranslationInfo>> future = controller.getCurrentRequest();
        List<MachineTranslationInfo> results = future.get(timeout, TimeUnit.SECONDS);
        
        assertFalse("Should have refreshed results", results.isEmpty());
    }
}
```


**Deliverables:**
- `MachineTranslationService` fully implemented and tested
- `MachineTranslationController` with cancellation logic
- `MachineTranslateTextArea` refactored (no threading)
- Updated tests passing reliably
- Integration guide for other panes

**Testing:**
- Unit tests for service (mock translators)
- Unit tests for controller (mock service/view)
- Updated acceptance tests
- Manual testing of MT functionality

---

### Phase 2: Translation Memory Matches (Week 5-6)

**Goal**: Refactor high-value, high-complexity component

**Why Matches Second**:
- Critical user-facing feature
- Single async operation (simpler than MT)
- Validates pattern on different complexity level

#### 2.1: Service Layer

```java
public class MatchesService implements EntryInfoService<List<NearEntry>> {
    
    private final IProject project;
    private final ExecutorService executor;
    
    public MatchesService(IProject project) {
        this.project = project;
        this.executor = EntryInfoExecutorManager.getExecutor();
    }
    
    @Override
    public CompletableFuture<List<NearEntry>> fetchInfo(
            SourceTextEntry entry, FetchContext context) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Business logic: TM search, scoring, filtering
                List<NearEntry> matches = project.getTranslationMemory()
                    .searchNearTranslations(entry);
                
                // Apply filters based on preferences
                matches = applyFilters(matches, context);
                
                // Sort by score
                matches.sort(Comparator.comparingInt(NearEntry::getScore).reversed());
                
                return matches;
                
            } catch (Exception e) {
                Log.log(e);
                return Collections.emptyList();
            }
        }, executor);
    }
    
    private List<NearEntry> applyFilters(List<NearEntry> matches, FetchContext context) {
        int minScore = Preferences.getPreferenceDefault(
            Preferences.EXT_TMX_MIN_SIMILARITY, 
            OConsts.FUZZY_MATCH_THRESHOLD);
        
        return matches.stream()
            .filter(match -> match.getScore() >= minScore)
            .collect(Collectors.toList());
    }
    
    @Override
    public void shutdown() {
        // Managed by shared executor
    }
    
    @Override
    public boolean isAvailable() {
        return project != null && project.isProjectLoaded();
    }
}
```


#### 2.2: Controller

```java
public class MatchesController extends EntryInfoController<List<NearEntry>> {
    
    private NearEntry activeMatch;
    
    public MatchesController(MatchesService service, MatchesTextArea view) {
        super(service, view);
    }
    
    @Override
    protected FetchContext createFetchContext(SourceTextEntry entry) {
        ProjectProperties pp = Core.getProject().getProjectProperties();
        return new FetchContext.Builder()
            .sourceLanguage(pp.getSourceLanguage())
            .targetLanguage(pp.getTargetLanguage())
            .build();
    }
    
    @Override
    protected void handleResult(List<NearEntry> result) {
        super.handleResult(result);
        
        // Set active match (first highest-score match)
        activeMatch = result.isEmpty() ? null : result.get(0);
        ((MatchesTextArea) view).setActiveMatch(activeMatch);
    }
    
    public NearEntry getActiveMatch() {
        return activeMatch;
    }
}
```


#### 2.3: View Refactoring

```java
@SuppressWarnings("serial")
public class MatchesTextArea extends JEditorPane 
        implements EntryInfoView<List<NearEntry>>, IPaneMenu {
    
    // Removed: extends EntryInfoThreadPane
    // Removed: threading logic
    
    private List<NearEntry> displayedMatches = new ArrayList<>();
    private NearEntry activeMatch;
    
    @Override
    public void displayResult(List<NearEntry> matches) {
        UIThreadsUtil.mustBeSwingThread();
        
        this.displayedMatches = matches;
        
        StringBuilder sb = new StringBuilder("<html><body>");
        for (int i = 0; i < matches.size(); i++) {
            NearEntry match = matches.get(i);
            sb.append("<div class='match' id='").append(i).append("'>");
            sb.append("<span class='score'>").append(match.getScore()).append("%</span>");
            sb.append("<span class='source'>").append(match.getSource()).append("</span>");
            sb.append("<span class='target'>").append(match.getTranslation()).append("</span>");
            sb.append("</div>");
        }
        sb.append("</body></html>");
        
        setText(sb.toString());
        firePropertyChange("matches", null, matches);
    }
    
    public void setActiveMatch(NearEntry match) {
        this.activeMatch = match;
        highlightMatch(match);
        firePropertyChange("activeMatch", null, match);
    }
    
    // ... other view methods
}
```


#### 2.4: Test Updates

```java
public class MatchesTest extends TestCoreGUI {
    
    @Test
    public void testMatches() throws Exception {
        openSampleProject(PROJECT_PATH);
        
        MatchesController controller = TestCoreState.getInstance().getMatchesController();
        
        // Wait for matches
        CompletableFuture<List<NearEntry>> future = controller.getCurrentRequest();
        List<NearEntry> matches = future.get(timeout, TimeUnit.SECONDS);
        
        assertFalse("Should have matches", matches.isEmpty());
        
        NearEntry activeMatch = controller.getActiveMatch();
        assertNotNull("Should have active match", activeMatch);
        assertTrue("Active match should be high-score", activeMatch.getScore() >= 80);
    }
}
```


**Deliverables:**
- `MatchesService` implemented
- `MatchesController` implemented
- `MatchesTextArea` refactored
- Tests updated and passing

---

### Phase 3: Glossary (Week 7)

**Goal**: Refactor component with incremental update pattern

**Glossary Specifics**:
- Multiple glossary files loaded incrementally
- Results accumulate over time
- Different UX pattern (streaming results vs. single response)

#### 3.1: Service with Streaming Support

```java
public class GlossaryService implements EntryInfoService<List<GlossaryEntry>> {
    
    private final GlossaryManager glossaryManager;
    private final ExecutorService executor;
    
    @Override
    public CompletableFuture<List<GlossaryEntry>> fetchInfo(
            SourceTextEntry entry, FetchContext context) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                String sourceText = entry.getSrcText();
                
                // Search all glossaries
                List<GlossaryEntry> entries = glossaryManager
                    .searchSourceMatches(entry);
                
                // Sort by relevance
                entries.sort(Comparator.comparing(GlossaryEntry::getSrcText));
                
                return entries;
                
            } catch (Exception e) {
                Log.log(e);
                return Collections.emptyList();
            }
        }, executor);
    }
    
    // ... standard methods
}
```


#### 3.2: Controller & View

```java
public class GlossaryController extends EntryInfoController<List<GlossaryEntry>> {
    // Standard pattern, no special handling needed
}

@SuppressWarnings("serial")
public class GlossaryTextArea extends JTextPane 
        implements EntryInfoView<List<GlossaryEntry>>, IPaneMenu {
    
    // Removed: extends EntryInfoThreadPane
    // Removed: CopyOnWriteArrayList
    
    private List<GlossaryEntry> displayedEntries = new ArrayList<>();
    
    @Override
    public void displayResult(List<GlossaryEntry> entries) {
        UIThreadsUtil.mustBeSwingThread();
        
        this.displayedEntries = entries;
        
        StyledDocument doc = getStyledDocument();
        try {
            doc.remove(0, doc.getLength());
            
            for (GlossaryEntry entry : entries) {
                doc.insertString(doc.getLength(), entry.getSrcText(), sourceStyle);
                doc.insertString(doc.getLength(), " = ", separatorStyle);
                doc.insertString(doc.getLength(), entry.getLocText() + "\n", targetStyle);
            }
        } catch (BadLocationException e) {
            Log.log(e);
        }
        
        firePropertyChange("entries", null, entries);
    }
    
    public List<GlossaryEntry> getDisplayedEntries() {
        return new ArrayList<>(displayedEntries);
    }
    
    // ... other methods
}
```


**Deliverables:**
- `GlossaryService` implemented
- `GlossaryController` implemented
- `GlossaryTextArea` refactored
- Tests updated

---

### Phase 4: Dictionary & MultipleTransPane (Week 8)

**Goal**: Complete migration of remaining panes

#### 4.1: Dictionary Service

```java
public class DictionaryService implements EntryInfoService<List<DictionaryEntry>> {
    
    private final List<IDictionary> dictionaries;
    private final ExecutorService executor;
    
    @Override
    public CompletableFuture<List<DictionaryEntry>> fetchInfo(
            SourceTextEntry entry, FetchContext context) {
        
        String sourceText = entry.getSrcText();
        
        // Search all dictionaries in parallel
        List<CompletableFuture<List<DictionaryEntry>>> futures = dictionaries.stream()
            .map(dict -> CompletableFuture.supplyAsync(() -> 
                dict.lookup(sourceText), executor))
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .flatMap(f -> f.join().stream())
                .sorted(Comparator.comparing(DictionaryEntry::getWord))
                .collect(Collectors.toList()));
    }
    
    // ... standard methods
}
```


#### 4.2: MultipleTransPane Service

```java
public class MultipleTransService implements EntryInfoService<MultipleTransInfo> {
    
    private final IProject project;
    private final ExecutorService executor;
    
    @Override
    public CompletableFuture<MultipleTransInfo> fetchInfo(
            SourceTextEntry entry, FetchContext context) {
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                // Scan project for alternative translations
                Map<String, List<TMXEntry>> alternatives = 
                    project.getAlternativeTranslations(entry);
                
                return new MultipleTransInfo(alternatives);
                
            } catch (Exception e) {
                Log.log(e);
                return MultipleTransInfo.empty();
            }
        }, executor);
    }
    
    // ... standard methods
}
```


**Deliverables:**
- All five panes migrated
- All tests passing
- Performance baseline established

---

### Phase 5: Deprecation & Cleanup (Week 9)

**Goal**: Remove old code, finalize migration

#### 5.1: Deprecate Old Classes

```java
/**
 * @deprecated Use {@link EntryInfoService} and {@link EntryInfoController} pattern instead.
 * This class will be removed in OmegaT 7.0.
 * 
 * Migration guide:
 * 1. Create a service implementing EntryInfoService<T>
 * 2. Create a controller extending EntryInfoController<T>
 * 3. Modify your pane to implement EntryInfoView<T> instead of extending this class
 * 4. Wire together in application initialization
 * 
 * See org.omegat.gui.exttrans.MachineTranslationService for reference implementation.
 */
@Deprecated(since = "6.1", forRemoval = true)
public abstract class EntryInfoThreadPane<T> extends EntryInfoPane<T> 
        implements IEntryEventListener {
    // ... existing code with deprecation warnings
}

/**
 * @deprecated Use CompletableFuture pattern in EntryInfoService implementations.
 * This class will be removed in OmegaT 7.0.
 */
@Deprecated(since = "6.1", forRemoval = true)
public abstract class EntryInfoSearchThread<T> extends Thread {
    // ... existing code
}
```


#### 5.2: Update Test Infrastructure

```java
// Remove old waiting methods
// @Deprecated
// protected void openSampleProjectWaitMatches(Path projectPath) { ... }

// Replace with unified approach
protected void openSampleProjectAndWait(Path projectPath) throws Exception {
    openSampleProject(projectPath);
    EntryInfoTestSupport.awaitAllPanesIdle();
}
```


#### 5.3: Documentation

1. **Migration Guide** (`docs/migration/entry-info-panes.md`)
   - Step-by-step for plugin developers
   - Code examples for each pattern
   - Common pitfalls and solutions

2. **Architecture Document** (`docs/architecture/entry-info-architecture.md`)
   - Design rationale
   - Component responsibilities
   - Extension points

3. **API Documentation**
   - Javadoc for all new interfaces/classes
   - Code examples in package-info.java

**Deliverables:**
- Deprecation warnings in place
- Migration guide published
- All documentation updated
- Plugin developer communication sent

---

### Phase 6: Testing & Validation (Week 10)

**Goal**: Comprehensive validation before release

#### 6.1: Test Coverage

1. **Unit Tests** (Target: 90%+ coverage)
   - All five service implementations
   - All five controllers
   - View display logic
   - Error handling paths

2. **Integration Tests**
   - End-to-end scenarios
   - Rapid entry navigation
   - Project load/unload
   - Concurrent operations

3. **Acceptance Tests**
   - All existing GUI tests passing
   - No flaky tests
   - Deterministic execution

#### 6.2: Performance Testing

```java
@Test
public void testThreadPoolEfficiency() {
    // Measure thread creation over 1000 entry activations
    int threadsBefore = getActiveThreadCount();
    
    for (int i = 0; i < 1000; i++) {
        activateEntry(i);
    }
    
    int threadsAfter = getActiveThreadCount();
    
    // With shared executor, thread count should be stable
    assertTrue("Should not create excessive threads", 
               threadsAfter - threadsBefore < 20);
}

@Test
public void testMemoryUsage() {
    // Measure memory over extended session
    Runtime runtime = Runtime.getRuntime();
    long memoryBefore = runtime.totalMemory() - runtime.freeMemory();
    
    for (int i = 0; i < 10000; i++) {
        activateEntry(i % 100);
        if (i % 1000 == 0) {
            System.gc();
        }
    }
    
    long memoryAfter = runtime.totalMemory() - runtime.freeMemory();
    long growth = memoryAfter - memoryBefore;
    
    // Memory growth should be bounded
    assertTrue("Memory leak suspected", growth < 50 * 1024 * 1024); // 50MB
}
```


#### 6.3: Stress Testing

- 10,000 entry navigations
- Rapid entry switching (< 100ms between)
- Multiple projects open/close cycles
- Plugin enable/disable during operation

**Deliverables:**
- Test suite at 90%+ coverage
- All tests passing consistently
- Performance benchmarks documented
- Stress test results published

---

## Post-Migration Architecture

### Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                     OmegaT Main Window                          │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │   Editor    │  │  Info Panes │  │   Status    │            │
│  │   Area      │  │  Container  │  │   Bar       │            │
│  └─────────────┘  └──────┬──────┘  └─────────────┘            │
└──────────────────────────┼──────────────────────────────────────┘
                           │
         ┌─────────────────┼─────────────────┐
         │                 │                 │
┌────────▼────────┐ ┌──────▼──────┐ ┌───────▼────────┐
│ MT Controller   │ │   Matches   │ │   Glossary     │  ...
│                 │ │  Controller │ │   Controller   │
└────┬─────────┬──┘ └──┬────────┬─┘ └───┬─────────┬──┘
     │         │       │        │       │         │
     │Service  │View   │Service │View   │Service  │View
     ↓         ↓       ↓        ↓       ↓         ↓
┌──────────┐ ┌────┐ ┌────────┐ ┌────┐ ┌────────┐ ┌────┐
│    MT    │ │ MT │ │Matches │ │Match│ │Glossary│ │Glos│
│ Service  │ │View│ │Service │ │View │ │Service │ │View│
│          │ │    │ │        │ │     │ │        │ │    │
│┌────────┐│ └────┘ │┌──────┐│ └────┘ │┌──────┐│ └────┘
││Executor││         ││Execut││         ││Execut││
││Service ││         ││or    ││         ││or    ││
│└────────┘│         │└──────┘│         │└──────┘│
└─────┬────┘         └────┬───┘         └────┬───┘
      │                   │                  │
      └───────────────────┼──────────────────┘
                          │
                ┌─────────▼──────────┐
                │  Shared Executor   │
                │  (Thread Pool)     │
                │                    │
                │  • Bounded threads │
                │  • Named threads   │
                │  • Graceful shutdown│
                └────────────────────┘
```


### Responsibility Matrix

| Layer | Responsibilities | What It MUST NOT Do |
|-------|------------------|---------------------|
| **Service** | • Business logic<br>• Data fetching<br>• Caching decisions<br>• Error handling<br>• Return CompletableFuture | • Access Swing components<br>• Manage UI state<br>• Know about controllers |
| **Controller** | • Lifecycle management<br>• Request cancellation<br>• Event listening<br>• Coordinate service ↔ view<br>• Thread handoff (async→EDT) | • Business logic<br>• Direct data access<br>• Rendering decisions |
| **View** | • Rendering<br>• User interactions<br>• Display state<br>• Fire property changes | • Threading<br>• Business logic<br>• Data fetching<br>• Direct event listening |

### Thread Lifecycle

```
Application Start
    ↓
[EntryInfoExecutorManager created]
    ↓
[Shared CachedThreadPool initialized]
    ↓
[Services created with executor reference]
    ↓
[Controllers created, register as event listeners]
    ↓
━━━━━━━━━━━━━━ OPERATION ━━━━━━━━━━━━━━
    ↓
Entry Activated
    ↓
[Controller.onEntryActivated()]
    ↓
[Cancel previous CompletableFuture]
    ↓
[Service.fetchInfo() → returns CompletableFuture]
    ↓
[Tasks submitted to shared executor]
    ↓
[Worker threads execute tasks]
    ↓
[CompletableFuture completes]
    ↓
[Controller.handleResult() via SwingUtilities.invokeLater]
    ↓
[View.displayResult() on EDT]
    ↓
━━━━━━━━━━━━━━ SHUTDOWN ━━━━━━━━━━━━━━
    ↓
Application Close
    ↓
[Controllers.dispose() called]
    ↓
[Cancel all in-flight CompletableFutures]
    ↓
[Unregister event listeners]
    ↓
[EntryInfoExecutorManager.shutdown()]
    ↓
[Executor.shutdown()]
    ↓
[Wait for termination (10s timeout)]
    ↓
[If timeout: shutdownNow()]
    ↓
[All threads stopped]
```


## Consequences

### Positive

#### 1. **Testing Reliability** (Critical Win)
```java
// OLD: Flaky, nondeterministic
@Test
public void testMT() {
    openProject();
    robot().waitForIdle();  // Doesn't wait for background threads!
    // May pass or fail randomly
    assertEquals(expected, pane.getResult());
}

// NEW: Deterministic, reliable
@Test
public void testMT() {
    openProject();
    List<MTInfo> result = controller.getCurrentRequest().get(5, TimeUnit.SECONDS);
    assertEquals(expected, result.get(0));
}
```


**Impact**: 
- Acceptance tests run reliably in CI/CD
- Test execution time reduced (no random waits)
- Easier to debug test failures

#### 2. **Resource Management** (Critical Win)
```
OLD Architecture:
Entry 1 → 5 threads created
Entry 2 → 5 more threads created
Entry 3 → 5 more threads created
...
After 1000 entries → 5000+ threads created

NEW Architecture:
Entry 1 → Tasks submitted to pool (reuses threads)
Entry 2 → Tasks submitted to pool (reuses threads)
Entry 3 → Tasks submitted to pool (reuses threads)
...
After 1000 entries → ~20 threads in pool (stable)
```


**Impact**:
- Reduced memory footprint
- No thread exhaustion
- Faster response (thread reuse)

#### 3. **Code Quality** (High Value)

**Maintainability Metrics**:
- Lines of code: -15% (removed boilerplate)
- Cyclomatic complexity: -30% (simplified control flow)
- Test coverage: +40% (unit testable services)
- Bug density: Expected -50% (fewer race conditions)

**Developer Experience**:
- Clear responsibility boundaries
- Easy to add new panes (follow pattern)
- Standard Java concurrency patterns
- Better IDE support (CompletableFuture autocomplete)

#### 4. **User Experience** (High Value)

- **No Stale Results**: Cancellation prevents old data from appearing
- **Faster Feel**: Thread pool reuse = quicker response
- **Smoother Navigation**: No UI freezing from thread creation overhead
- **Consistent Behavior**: All panes behave predictably

#### 5. **Extensibility** (Medium Value)

**Easy to Add Features**:
- Timeouts: `fetchInfo().orTimeout(5, TimeUnit.SECONDS)`
- Retry logic: `fetchInfo().exceptionally(ex -> retryFetch())`
- Caching: Service layer can implement without UI changes
- Throttling: Control at service level
- Progress reporting: CompletableFuture progress callbacks

### Negative

#### 1. **Migration Effort** (High Cost)

**Estimated Effort**: 10 weeks (1 developer)
- Phase 0: 2 weeks (infrastructure)
- Phase 1: 2 weeks (MT - reference impl)
- Phase 2: 1.5 weeks (Matches)
- Phase 3: 1 week (Glossary)
- Phase 4: 1 week (Dictionary + MultipleTrans)
- Phase 5: 1 week (Cleanup)
- Phase 6: 1.5 weeks (Testing)

**Risk**: Regressions during migration

**Mitigation**: 
- Feature flags for gradual rollout
- Parallel testing (old vs new)
- Comprehensive test suite
- Beta testing period

#### 2. **Breaking Changes** (Medium Cost)

**Affected**: Plugins that extend `EntryInfoThreadPane`

**Mitigation**:
- Deprecation period (one major version)
- Migration guide with examples
- Backward compatibility shim if needed
- Early communication to plugin developers

#### 3. **Learning Curve** (Low Cost)

**Challenge**: Team needs to understand:
- `CompletableFuture` API
- Service-Controller-View pattern
- Proper async→EDT handoff

**Mitigation**:
- Code review focus on new patterns
- Internal documentation
- Reference implementation (MT pane)
- Pair programming during migration

#### 4. **Increased Component Count** (Low Cost)

**OLD**: 1 class per pane (5 total)
**NEW**: 3 classes per pane (15 total) + shared infrastructure (3)

**Total**: 5 → 18 classes

**Why This Is Acceptable**:
- Each class has single, clear responsibility
- Easier to test individually
- Standard pattern (easier to understand)
- Shared infrastructure amortizes cost

### Neutral

#### 1. **Performance** (Expected Neutral to Positive)

**Thread Pool Overhead**:
- Slight overhead from task submission vs. direct thread creation
- Offset by thread reuse benefits
- Expected: <5ms difference in response time (negligible)

**Memory**:
- More objects (services, controllers, futures)
- Less memory overall (fewer threads)
- Expected: Net -10% to -20% memory usage

#### 2. **Code Size** (Slight Increase)

**LOC Analysis**:
- OLD: ~500 LOC per pane × 5 = 2500 LOC
- NEW: ~800 LOC per pane set (service+controller+view) × 5 = 4000 LOC
- NEW: +300 LOC shared infrastructure
- Total: 2500 → 4300 LOC (+72%)

**Why Increase Is OK**:
- Explicit is better than implicit
- Each line has clear purpose
- Better documentation
- Higher test coverage
- Lower cognitive complexity per component

## Risk Assessment

### High Risks

#### Risk: Regression in Core Functionality
**Probability**: Medium  
**Impact**: Critical  
**Mitigation**:
- Comprehensive test suite before migration
- Feature flags for gradual rollout
- Beta testing period
- Rollback plan

#### Risk: Plugin Incompatibility
**Probability**: High (if plugins extend EntryInfoThreadPane)  
**Impact**: High  
**Mitigation**:
- Survey existing plugins
- Early communication (6 months before removal)
- Provide adapter/shim if widely used
- Deprecation period (1 major version)

### Medium Risks

#### Risk: Team Resistance to Change
**Probability**: Medium  
**Impact**: Medium  
**Mitigation**:
- Present this ADR for discussion
- Demonstrate benefits with MT pilot
- Involve team in design decisions
- Pair programming during migration

#### Risk: Schedule Overrun
**Probability**: Medium  
**Impact**: Medium  
**Mitigation**:
- Phased approach (can stop after Phase 1-2)
- Buffer time in estimates (10 weeks → 12 weeks)
- Regular progress reviews

### Low Risks

#### Risk: Performance Degradation
**Probability**: Low  
**Impact**: Medium  
**Mitigation**:
- Benchmark before/after
- Performance tests in Phase 6
- Profile in production-like environment

## Alternatives Considered

### Alternative 1: Patch Current Architecture
**Description**: Keep `EntryInfoThreadPane`, add thread tracking and cancellation

**Pros**:
- Minimal changes
- No breaking changes
- Fast to implement

**Cons**:
- Doesn't fix root cause (mixed responsibilities)
- Still difficult to test
- Accumulates more technical debt
- Doesn't improve maintainability

**Decision**: **Rejected** - Only treats symptoms

### Alternative 2: Reactive Streams (RxJava/Project Reactor)
**Description**: Use reactive programming paradigm

**Pros**:
- Powerful composition operators
- Built-in backpressure
- Elegant async handling

**Cons**:
- Large dependency (RxJava = 2.5MB)
- Steep learning curve
- Overkill for this use case
- Not standard Java

**Decision**: **Rejected** - Too heavyweight, `CompletableFuture` sufficient

### Alternative 3: Actor Model (Akka)
**Description**: Each pane is an actor receiving messages

**Pros**:
- Inherent thread safety
- Elegant concurrency model
- Supervision trees for error handling

**Cons**:
- Major dependency (Akka = 20MB+)
- Complete paradigm shift
- Overkill for this use case
- Scala dependency

**Decision**: **Rejected** - Too radical, unnecessary complexity

### Alternative 4: Keep EntryInfoThreadPane, Add Abstract Methods
**Description**: Add `cancelSearch()`, `awaitCompletion()` abstract methods

**Pros**:
- Incremental improvement
- Backward compatible

**Cons**:
- Still mixed responsibilities
- Forces all subclasses to implement threading
- Doesn't solve testing issues
- Band-aid solution

**Decision**: **Rejected** - Perpetuates bad design

### Alternative 5: EventBus Pattern
**Description**: Decouple via publish-subscribe event bus

**Pros**:
- Loose coupling
- Easy to add new listeners
- Popular in Android development

**Cons**:
- Debugging is harder (indirect flow)
- Performance overhead
- Doesn't solve threading issues
- Adds complexity without clear benefit

**Decision**: **Rejected** - Unnecessary indirection, doesn't address core problem

### Why Service-Controller-View Wins

1. **Standard Pattern**: Well-understood, widely used
2. **Right Abstraction Level**: Not too simple, not too complex
3. **Built-in Java API**: `CompletableFuture` is standard since Java 8
4. **Testability**: Each layer can be unit tested
5. **Incremental Migration**: Can implement pane-by-pane
6. **Clear Responsibilities**: Each component has one job
7. **Extensibility**: Easy to add features without major refactoring

## Success Criteria

### Must Have (Release Blockers)

1. **All Five Panes Migrated**
   - MachineTranslateTextArea
   - MatchesTextArea
   - GlossaryTextArea
   - DictionaryTextArea
   - MultipleTransPane

2. **Zero Flaky Tests**
   - All acceptance tests pass 100 times consecutively
   - No random failures in CI/CD

3. **Proper Thread Cleanup**
   - No threads leak after project close
   - Clean shutdown in < 2 seconds
   - Memory usage stable over 10,000 entry activations

4. **Backward Compatibility**
   - Deprecation warnings in place
   - Migration guide published
   - Old code still compiles (with warnings)

### Should Have (Nice to Have)

1. **Performance Improvement**
   - Response time ≤ current implementation
   - Memory usage -10% or better

2. **Test Coverage**
   - Unit test coverage ≥ 90% for new code
   - Integration tests for all panes

3. **Documentation**
   - Architecture documentation
   - Developer guide
   - Plugin migration guide

### Could Have (Future Enhancements)

1. **Advanced Features**
   - Configurable timeouts per service
   - Retry logic for transient failures
   - Progress indicators for slow operations

2. **Monitoring**
   - Metrics for service performance
   - Thread pool statistics
   - Error rate tracking

## Timeline

```
Week 1-2:  Phase 0 - Foundation
Week 3-4:  Phase 1 - Machine Translation
Week 5-6:  Phase 2 - Matches
Week 7:    Phase 3 - Glossary
Week 8:    Phase 4 - Dictionary & MultipleTrans
Week 9:    Phase 5 - Deprecation & Cleanup
Week 10:   Phase 6 - Testing & Validation

Week 11-12: Buffer / Polish
Week 13:   Beta release
Week 14-16: Beta testing period
Week 17:   Production release
```


**Total**: ~4 months from start to production

## Migration Path for Plugin Developers

### Example: Custom Pane Plugin

**OLD Code**:
```java
public class MyCustomPane extends EntryInfoThreadPane<MyData> {
    @Override
    protected void startSearchThread(SourceTextEntry newEntry) {
        new MySearchThread(newEntry).start();
    }
    
    protected class MySearchThread extends EntryInfoSearchThread<MyData> {
        @Override
        protected MyData search() {
            // Fetch data
            return data;
        }
    }
}
```


**NEW Code**:
```java
// 1. Create service
public class MyCustomService implements EntryInfoService<MyData> {
    private final ExecutorService executor = EntryInfoExecutorManager.getExecutor();
    
    @Override
    public CompletableFuture<MyData> fetchInfo(SourceTextEntry entry, FetchContext ctx) {
        return CompletableFuture.supplyAsync(() -> {
            // Fetch data (same logic as before)
            return data;
        }, executor);
    }
    
    @Override
    public void shutdown() { /* managed by framework */ }
    
    @Override
    public boolean isAvailable() { return true; }
}

// 2. Create controller
public class MyCustomController extends EntryInfoController<MyData> {
    public MyCustomController(MyCustomService service, MyCustomPane view) {
        super(service, view);
    }
    
    @Override
    protected FetchContext createFetchContext(SourceTextEntry entry) {
        return new FetchContext.Builder().build();
    }
}

// 3. Simplify view
public class MyCustomPane extends JEditorPane implements EntryInfoView<MyData> {
    @Override
    public void displayResult(MyData data) {
        setText(data.toString());
    }
    
    @Override
    public void showLoading() { /* optional */ }
    
    @Override
    public void showError(String msg) { setText(msg); }
    
    @Override
    public void clear() { setText(""); }
}

// 4. Wire together (in plugin initialization)
MyCustomService service = new MyCustomService();
MyCustomPane view = new MyCustomPane();
MyCustomController controller = new MyCustomController(service, view);
```


## Open Questions

1. **Should we provide a backward compatibility shim?**
   - Option A: Yes, for one release cycle
   - Option B: No, clean break with deprecation period
   - **Recommendation**: Option A if plugin survey shows wide usage

2. **Should all panes share one executor or have dedicated executors?**
   - Option A: Single shared executor (simpler)
   - Option B: One per pane type (more isolation)
   - **Recommendation**: Option A, with option to configure per-service if needed

3. **Should we implement gradual rollout via feature flags?**
   - Option A: Yes, enable per-pane
   - Option B: No, all at once after testing
   - **Recommendation**: Option A for Phase 1-2, Option B for Phase 3+

4. **What timeout should we use for service operations?**
   - Current: No timeout (can hang indefinitely)
   - Proposed: 30 seconds default, configurable per service
   - **Recommendation**: Discuss with team based on MT engine behavior

## References

- Current implementation: `org.omegat.gui.common.EntryInfoThreadPane`
- Test infrastructure: `org.omegat.gui.main.TestCoreGUI`
- Java Concurrency: [CompletableFuture Guide](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)
- Pattern Reference: Martin Fowler's [GUI Architectures](https://martinfowler.com/eaaDev/uiArchs.html)
- Thread Management: [Java Executors Best Practices](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html)

---

**Decision Date**: 2025-10-12  
**Proposed By**: [Development Team]  
**Status**: **Awaiting Review**  
**Reviewers**: Core development team, plugin maintainers  
**Target Decision Date**: 2025-11-26  
**Target Implementation Start**: 2025-12-01  